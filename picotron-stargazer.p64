picotron cartridge // www.picotron.net
version 2

:: entities/
:: entities/base.lua
--[[pod_format="raw",created="2025-04-14 21:29:02",modified="2025-05-22 17:03:29",revision=1982]]
function build_entity()
	return {
        x = 0, y = -64,
        dx = 0, dy = 0,
        grounded = true,
        width = 0.8,
        height = 0.8,
        walk_speed = 1,
        jump_force = -2.4,
	}
end

function walking_animator(e, idle_frame, start_frame, frame_limit, air_frame, x_offset, y_offset)
	e.wa_frame = 0
	e.wa_limit = frame_limit
	
	e.wa_start_frame = start_frame
	e.wa_idle_frame = idle_frame
	e.wa_air_frame = air_frame
	
	e.wa_x_offset = x_offset
	e.wa_y_offset = y_offset
	
	e.wa_left = false
	return function(e)
		if abs(e.dx) < 0.05 then
			e.dx = 0
		end
		if (not e.grounded) then
			if (e.dy > 0.5) then
				if (e.dy > 3.5) then
					spr(e.wa_air_frame+2,x_offset, y_offset, e.wa_left)
				else
					spr(e.wa_air_frame+1,x_offset, y_offset, e.wa_left)
				end
			else
				spr(e.wa_air_frame,x_offset, y_offset, e.wa_left)
			end
		else
			if (e.dx < 0) e.wa_left = true
			if (e.dx > 0) e.wa_left = false
			if (abs(e.dx)>0.1) then
				e.wa_frame += abs(e.dx/3)
				if (e.wa_frame >= e.wa_limit) then
					e.wa_frame = 0
				end
				spr(flr(e.wa_start_frame+e.wa_frame), x_offset, y_offset, e.wa_left)
			else
				e.wa_frame = 0
				spr(e.wa_idle_frame, e.wa_x_offset, e.wa_y_offset, e.wa_left)
			end
		end
	end
end
:: entities/player.lua
--[[pod_format="raw",created="2025-04-14 21:28:33",modified="2025-05-22 17:45:13",revision=2284]]
include "entities/base.lua"


local anchoring = {
	-- POINTING ORDER: left left-up up right-up right
	--
	{} 	
}
local swing_frames_right = {
	 {24, {0,  0, 13, 0.5, 0.5}}, -- L
 	 {25, {0,  3,  5, 0.5, 0.5}}, -- L U
 	 {26, {0, 10,  1, 0.5, 0.5}}, --   U
 	 {27, {0, 18,  3, 0.5, 0.5}}, -- R U
 	 {28, {0, 19, 13, 0.5, 0.5}}, -- R
}

local swing_frames_left = {
 	 {24, {0, 16, 13, 0.5, 0.5}}, -- R
 	 {25, {0, 13,  5, 0.5, 0.5}}, -- R U
 	 {26, {0,  6,  1, 0.5, 0.5}}, --   U
 	 {27, {0, -2,  3, 0.5, 0.5}}, -- L U
	 {28, {0, -3, 13, 0.5, 0.5}}, -- L
}

function recalc_frame_data()
	__re(swing_frames_right)
	__re(swing_frames_left)
end

local function swing_animator(e)
	e.swing_timer = 0
	e.swinging = false
	return function()
		-- Draw swing
		local data_source = e.wa_left and swing_frames_left or swing_frames_right
		e.swing_timer += 0.4
		if e.swing_timer < #swing_frames_right then
			local frame_number = flr(e.swing_timer)+1
			local frame_data   = data_source[frame_number]
			
			local frame_number_chr          = frame_data[1]
			local frame_data_pickaxe        = frame_data[2]
			local s_number                  = frame_data_pickaxe[1]
			local frame_data_pickaxe_x      = frame_data_pickaxe[2]
			local frame_data_pickaxe_y      = frame_data_pickaxe[3]
			local frame_data_anchor_x       = frame_data_pickaxe[4]
			local frame_data_anchor_y       = frame_data_pickaxe[5]
			
	
			local s        = get_spr(s_number)
			local s_width  = s:width()
			local s_height = s:height()
			
			local spr_x_offset = -s_width * frame_data_anchor_x
			local spr_y_offset = -s_height * frame_data_anchor_y

			--spr(s_number, -5+frame_data_pickaxe_x+spr_x_offset, -8+frame_data_pickaxe_y+spr_y_offset)
			circfill(-5+frame_data_pickaxe_x,-8+frame_data_pickaxe_y,1)
			spr(frame_number_chr,-5,-8,e.wa_left)
		else
			e.swinging = false
		end
	end,
	function ()
		-- Trigger swing
		e.swing_timer = 0
		e.swinging = true
	end
end

function build_player()
	local base = build_entity()
	
	base.width = 0.7
	base.update = update
	
	local draw_swing, trigger_swing = swing_animator(base)
	
	local wa = walking_animator(base, 1, 2, 6, 9, -5, -8)
	base.draw = function(e)
		if (e.swinging) then
			draw_swing()	
		end
		if not e.swinging then
			wa(e)
		end
		prints(e.x .. " " .. e.y, -32, -32)
	end
	base.prev_whole_x = flr(base.x/8)
	base.prev_whole_y = flr(base.y/8)
	base.update = function(e)
		-- Player input
		-- e.dx = (input & 1 and e.walk_speed) or (input & 2 and -e.walk_speed) or 0
		e.dx *= 0.8
		if (key("a")) then 
			e.dx -= e.walk_speed*0.2
		elseif (key("d")) then 
			e.dx += e.walk_speed*0.2
		end
		
		-- Jumping
		if e.grounded and key("w") then
			e.dy = e.jump_force
			e.grounded = false
		end 
		
		if not (key("w") or e.grounded) and e.dy < -1 then
			e.dy = -1
		end
		
		if (keyp("t")) trigger_swing()
		
		local whole_x = flr(e.x/8+0.5)
		local whole_y = flr(e.y/8+0.5)
		
		if e.prev_whole_x != whole_x or e.prev_whole_y != whole_y then
			--chunk.place_light_in_world(whole_x, whole_y, 32)
			--chunk.break_light_in_world(base.prev_whole_x, base.prev_whole_y)
		end
	
		e.prev_whole_x = whole_x
		e.prev_whole_y = whole_y
	end
	
	base.equipped_sprite = 16
	return base
end
:: entities/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTE0IDIxOjI4OjIzIixtb2RpZmllZD0iMjAyNS0w
NS0yMiAxNzo0NToxNCJdXQ==
:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTA5IDE4OjU5OjA1Iixtb2RpZmllZD0iMjAyNS0w
NS0yMiAxNzo0NToxMyIscmV2aXNpb249MzQ0OV1dbHo0AD0EAADmOQAA_CZ7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3g9MC4wNgEAETcYAPwQeT04LjMyNjY3
MjY4NDY4ODdlLTE3LHpvb209MTV9LGEA-xoaGaAaCQYHCZApFwmAfxmAFw8VFw6QFw4XDpAPEEeQ
Bw03kF2ALhAuMH0AZG9tcC4gLiB9AEAfRvoAEU_QLi3Q_wBCH0d_ABQfwH4AQh9XfgARP6A_QHcB
Zl89LoAucHcBZk8tAC5wfwBB8Ao-H3B_YE4ATjBeEE4QbiCuUI6AXpBegG6AFgD-Aj4wXiA_EF4w
TgBOUI5wbpAefQFf-wMADlAODQcNNw0OUA59DlAO8AyEAEAbNoQAP5BHkIYAYBsmhgAv8AqHAGIf
8FQAkKwEBAQ3Pxw8HxARWQADSQAfMIsABw8yABqyCgoEIAZgBgdwBgcGAM91F38VF4AXcBeQB1BK
AAweNkoA8ho3IAY3QAYHDxVQBgcOBQ5AFwAOBQ4wBgcQDgUOIAYwDgUOEAdADgUOcAQAD2EAHvoJ
FhcwFlcQFwAPFQUAFwAGIA4FIAcwDgVwAwAfMFgAHfEDEAcWBwZgNwZgDxUHBlAOBQ4HrAAwABcg
sgAQF74AIDAHywAQQNYAT2AFDnBiAB0xUAaQXwHAgAYHdQYHfxUXcBdgBAAvByBKAB0zBQ8VPgEy
DkAHmgABpgAhBgezABEGYAHPBgdQDgYHQCYXIBYnYgAeMzAPFUkBBlIBAWsB-wAGABYADgUABgcQ
FzYXMDdZAB5QcA8VBWCeABFAqgASMLcAAhwCEwcqAt8OBQ5QFw5gBjdgJhcQYQAaAP0CH1XeCBUP
IwIODzkJIV6ADl2QHjoJD1wADw0cCIknDxUXkCcOF1oAHxBaACCwWCoJoCoJBgeQORdYAIk3DxUH
kDcOB1gAHwBYACAaaVgAIVeQWgD-Ag8QJw8VB4AOBw8QN4AeTQ4AWAAeH-AyAH70ACAgBPD-awbw
DQYH8A4GBwgA-wZl8AcXbxXwBxfwDxfwDhfwEAfw-1ZZAAseN1gAoP-LBjfwCQY38As1BSHwDAAD
IfALNwUi8AocAyHwCSoDIfAI2gMj8A4FAA9sAB_TwBYX8AoWV-AIQAUi8AdBBW7wCg4F8A4EAB-g
YwAfELRJBWDwDTcG8A1LBSHwDEwFAGEAUA4AF-AJ8QMxF-AItQQh8AfCBCDwBtAAEA3UAA9vAB5D
VwbwEJYBYA8GB-AGdQUAIX8VkAESDQYATwfw-2pYAAwPUgJeDzIAHwJdAS--8zUACx81mAAfDzIA
----------------------------------------------------x1EICAQFBwIAEhcIAB8VDgAW
HwVpAP-CP-8lMDMAHh8kMwAfHyMzAB8fIjMAHx8hMwAeH-AyAAtQPTE2fX0=
:: gfx/1.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTEyIDIwOjA4OjQzIixtb2RpZmllZD0iMjAyNS0w
NS0yMiAxNzo0NToxMyIscmV2aXNpb249MzUwOF1dbHo0AJgDAABTNgAA8xR7WzBdPXtibXA9cHh1
AEMgCAgE8DAsZmxhZ3M9MCxwYW5feAgA2nk9MCx6b29tPTE2fSwyAFF7DxsLDgIAQQ8UDg0CACED
DQIAL-0RTAAdL-8UfwAe-wEPFBQeDxUOHQ4ELh0OFB4NCgAHA1oAPzEyOFwAFvATGwsDAA4LAxAO
AA8VAw4AHQALDg0DCw4ADQ4NAA0OAw4LDR8AUAADDgANHwAVAx8AEAMEAA9xAB9-jQH9EwH9AgQB
HlAbCwMPFAYA8AQfFQ8bBA8UAw8bLxUECw8bDxQDBgAQFR4A0C8UDxsDDgsEDxQOCwPQAAApAGAO
LxUDCw4nABAOJgBfDgMdDgN-AB3haQ8ZWgkOWg4JfikOORoKAC86fkUAHaNPFQAOAD4ADgBeCAAb
HhAAH05SAB0v8TB-Ah_fFQ8VXxQfFf8UhAEe_CMADxQEDx8PDwgPGAIPFQUPFgYHDxcPDg8eAQ8Q
DxEMDxwPHQ0PEg8TAw8bCw8aCgkPGQwACiUACD8ACFgAD5QAGl8QEATw8DIAsPAUCAgEED8SMA4Q
DkAOAUABDx8KASABDxgKDx8PGAEQAQgKBwgHAH8HCggBIDEQ5QMgPyDxL5EAHV8PFf8ULyoBHw8y
AOIPVQYif4EPIPETDvGGAx6OjxQPGP8UEw-CAw8KAREPMgDiD6ABIm-xCg8g8RVgBR8QCp8BHxUE
AR8PMgDiD5oBI18DDyBRDpwBIRAD-AYvDxWgAf8YDzIAHwCgAX8VDyBRHvECnAAfDzIA--90cAgI
BD8YPxQEAPECLxhPFB8YvxQfFU8ULxU-FD8EAA_AAB8PMgD-----------------------------
----------8aAMYl3yUnTgduJ24HbgdOJ74_AB5QJAcOB04EAAFCAC9uB0IAHv8BnyMHXgcOB24H
Xgd_B04XzkAAHhUiQAA-XgduwgAfUp8hB14XvAAfXj4AH3OQB1AHAAdABABPUAfwBeQBHw8yAP--
-9MPaAUuL-8lnSgeRg8kDyUEABcfDAA3DyUfDAAPHAA1Lw8k1QAeHyTVAB82Iw8kBAAXHwwANw8k
HwwADxwANS8PI9UAHh8j1QAfNiIPIwQAFx8MADcPIx8MAA8cADUvDyLVAB4fItUAHzYhDyIEABcf
DAA3DyIfDAAPHAA1Lw8h1QAeLyEweTIfMyEADjAzXw4ADhAODgAVHwCNLDxQPTE2fX0=
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTA5IDE5OjUyOjUzIixtb2RpZmllZD0iMjAyNS0w
NS0yMiAxNzo0NToxNCJdXQ==
:: map/
:: map/debug.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTEzIDE3OjA0OjExIixtb2RpZmllZD0iMjAyNS0w
NS0yMiAxNzo0NToxMyIscmV2aXNpb249Mjc0N11dbHo0ALkDAACncgAA-w97e2JtcD11c2VyZGF0
YSgiaTE2IiwxMzgsNTMsIjABAP--------------------------tTkxMDcEAA8gAA0PKAL-7g8g
ABQPKAL--9wfMQIAAA8YAAEOMAAPFAADDBwADwEAwQ4IAg8gAAMP-ADDHzEQAAoPFAAADyAAAg8B
AP-ODOQBFzECAA8YABEEHAAPAQD-zgzkAQ70AQ80AC81MTA0BAAPAQCxBFwGBAgADAwADwEAwQ-0
AQEIAgAPGAABDAEADhQACBwABCQCHzYsArYEFAIECAAMDAAPAQD-IgQcAg8oArkIGAIPvAodHzEC
AFAPAQCpTzEwMzABAO0CxgEfMgQAFB81BAAQHzIEAAQOMAIPKALFHzE8A7wCrgAfMgQADB81BAAk
HzIEAAIPAQChCCgCHzECABIfMgQAFA8CAD8MAQAfMQIAMh8yBAAAHzUEADQfMgQABA9QA2MPcAAE
D1gBIB8yBACMDAIAHzIEADgfNQQATB8yBAAEHzEoAlgfMhACFB8yBAD-BR81BABUHzIEAAQKAgAP
EAIvDwIABR4yEAAPBAD-Hx81BABUHzIEAA0PFAIwHzIEAGwfNQQAEB8yBAB8HzUEAIwfMigCLB8y
BAB8HzUEADAXMgQAHzUEAPQeMigCDzwEmgwEAB81BAD-RR8yKAIYHzIEAJAfNQQA-0EfMiQCFg8o
Av----8THzIkAhoPKAL-4B8yJAIiDygC-9gfMiQCKg8oAv-UHzIkAi4PKAIfFzcMAAwQAB83EAAE
CBQADwQAJR81BAD-JQRAAQ9QBF0I_AEMDAAbMgwADhQADwQAJx81BAD-DQQoAQ8YAjcPUAQzDwgA
AQgEAB4yEAAPBAAqHzUEAP8FHzIYAhIIDAAPKAInD4AVGR83EAAEHzcUAAUPBABAHzUEAMgfMgQA
Hg8BABgPKALcDwQAWRc1CAAPBABBHjIEAA8oAoQOLAIPBAB7D7gACx8yBABgFzUIAA8EACkfMiAC
lg4sAhUxiAAPJAKNDzgCLA-oAKoOAQAPLALhD4wnQg90Ah0PJAL-Bw8wAm8CAgAPAQCEDxQC7g8s
Ag8VMegADwQAPwYCAA8BAP_uGTECAB8yBAA0DxwCCg80Av_9BAIAHzIEABQGAgAPAQD-3h8xAgAY
DwEA---------------------8jxCyIpLGhpZGRlbj1mYWxzZSxwYW5feD0tNTU0CwDyAXk9LTE0
Mix0aWxlX2g9MTYKABB3CgCAem9vbT0yfX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTA5IDE5OjUyOjUzIixtb2RpZmllZD0iMjAyNS0w
NS0yMiAxNzo0NToxNCJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTA5IDE4OjU5OjA1Iixtb2RpZmllZD0iMjAyNS0w
NS0yMiAxNzo0NToxMyIscmV2aXNpb249MzI1Nl1dbHo0ALYAAAAzCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-KaoB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww98D-8PHPDFD-gKD-8PgA-3Dw0B8AkBEAYOMgAG
XygP--DGMAD------58f-wEArM-ID0AADxBA--_w8HALAA0BMQAblRAADwEA-9tQ-----94=
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA0LTA5IDE5OjUyOjUzIixtb2RpZmllZD0iMjAyNS0w
NS0yMiAxNzo0NToxNCJdXQ==
:: chunk.lua
--[[pod_format="raw",created="2025-04-12 18:54:32",modified="2025-05-22 17:45:13",revision=4655]]
--[[
  [x] Chunk allocation
  [x] Chunk loading -> Loads from debug map
  [x] Chunk rendering
  [x] Store chunks to file system
  [x] Load chunks back from fs
]]

-- Sooooooo
-- We need to solve a few tasks
-- 1. Load chunks to memory
-- 2. Render them to screen
-- HOW 2 do? Either
--- Do all the everything manually <- tried this, 3x slower
--- OR
--- Leverage Picotron's native crap <- went with this!

include "constants.lua"
include "logging.lua"
include "generator.lua"
include "util.lua"

chunk = {}
LOADED_CHUNKS = {}
ALLOCATION_TABLE = {}
RENDER_CHUNK_HEAP = userdata("i16",CHUNK_SIZE*512,CHUNK_SIZE)
WORLD_NAME = "test_world"


local center_x = 0
local center_y = 0

function chunk.set_tile_in_world(x,y,b)
	local c = chunk.get_chunk_by_world_pos(x,y)
	
	if (c) then
		local x_in_chunk = x%CHUNK_SIZE
		local y_in_chunk = y%CHUNK_SIZE
		c.tiles:set(x_in_chunk,y_in_chunk,b)
		local tile = b == 0 and 0 or b + 256
		update_displayed_tile(tile, c, x_in_chunk, y_in_chunk) 
		c.changed = true
	end
	
end

function chunk.get_tile_in_world(x,y)
	local x,y = flr(x), flr(y)
	local chunk_with_block = chunk.get_chunk_by_world_pos(x,y)
	if (not chunk_with_block) return nil
	return chunk_with_block.tiles:get(x%CHUNK_SIZE,y%CHUNK_SIZE)
end

function chunk.mutate_light_in_world(x,y,delta)
	local x,y = flr(x), flr(y)
	local cx, cy = x%CHUNK_SIZE,y%CHUNK_SIZE
	local chunk_with_block = chunk.get_chunk_by_world_pos(x,y)
	if (not chunk_with_block) return nil
	chunk_with_block.changed = true
	
	local new_light_level = chunk_with_block.light:get(cx,cy)-delta
	chunk_with_block.light:set(cx,cy,new_light_level)
	
	-- update visual chunk
	local light_tile = 511-mid(0,8,new_light_level)
	RENDER_CHUNK_HEAP:set( chunk_with_block.light_tile_idx+cx, cy, light_tile )
end

function chunk.set_center(x,y)
	send_message(CHUNK_PROCESS, { event = "msg" } )
	center_x = x
	center_y = y
end

function set_world_name(name)
	WORLD_NAME = name
	mkdir(SAVEGAME_DIRECTORY .. "/" .. WORLD_NAME)
end

function chunk.init()
	mkdir(SAVEGAME_DIRECTORY)
	mkdir(SAVEGAME_DIRECTORY .. "/" .. WORLD_NAME)
	memmap(RENDER_CHUNK_HEAP,0x100000)
end

function chunk.build_chunk()
	return {
		tiles = userdata("i16",CHUNK_SIZE,CHUNK_SIZE),
		bg = userdata("i16",CHUNK_SIZE,CHUNK_SIZE),
		light = userdata("i16",CHUNK_SIZE,CHUNK_SIZE),
		light_sources = {}
	}
end

--[[
 Allocate and add a new chunk to the world
 cx, cy: world position in whole chunks
 c: chunk instance
]]

function allocate_drawable_chunk()
	-- Find an unallocated chunk in heap by looking for a "false"
	local alloc_idx = indexof(ALLOCATION_TABLE, false)
	-- If we get a nil, that means we need a new slot
	if alloc_idx == nil then 
		alloc_idx = #ALLOCATION_TABLE+1 
	else
	end
	-- Mark the slot as allocated
	ALLOCATION_TABLE[alloc_idx] = true
	return alloc_idx
end

function chunk.add_chunk(cx,cy,c)
	local chunk_id = cx .. "_" .. cy
	LOADED_CHUNKS[chunk_id] = c
	local alloc_idx = allocate_drawable_chunk()
	local bg_alloc_idx = allocate_drawable_chunk()
	local light_alloc_idx = allocate_drawable_chunk()
	-- Finally, write to the heap...
	-- The heap is structured like a long-ass map, 8 in height and 1024 in length
	-- This can store 128 map layers
	-- TODO optimize this
	local write_offset = alloc_idx * CHUNK_SIZE
	local bg_write_offset = bg_alloc_idx * CHUNK_SIZE
	local light_write_offset = light_alloc_idx * CHUNK_SIZE
	local source_tiles = c.tiles
	local source_bg = c.bg
	local source_light = c.light
	
		-- Precalculate some stuff...
	c.own_id = chunk_id
	c.alloc_idx = alloc_idx
	c.bg_alloc_idx = bg_alloc_idx
	c.light_alloc_idx = light_alloc_idx
	
	c.tile_idx = write_offset
	c.bg_tile_idx = bg_write_offset
	c.light_tile_idx = light_write_offset
	
	c.screen_x = cx * CHUNK_SIZE_IN_PIXELS
	c.screen_y = cy * CHUNK_SIZE_IN_PIXELS
	c.x = cx
	c.y = cy
	bar_start("Chunk adding")
	for ix=0,CHUNK_SIZE-1 do
		for iy = 0,CHUNK_SIZE-1 do
			local tile = 256 + source_tiles:get(ix,iy)
			
			update_displayed_tile(tile, c, ix, iy)
			
						
			-- Light is special. Tiles 511-n correspond to darkening levels.
			local light_tile = 511-max(0,source_light:get(ix,iy))
			RENDER_CHUNK_HEAP:set( light_write_offset+ix, iy, light_tile )
		end
	end
	bar_end("Chunk adding")

end

function chunk.update_all_light_in_chunk(c)
	local source_light = c.light
	local light_write_offset = c.light_tile_idx
	for ix=0,CHUNK_SIZE-1 do
		for iy = 0,CHUNK_SIZE-1 do
			local light_tile = 511-max(0,source_light:get(ix,iy))
			RENDER_CHUNK_HEAP:set( light_write_offset+ix, iy, light_tile )
		end
	end
end

function update_displayed_tile(tile, chunk, ix, iy)
	local write_offset = chunk.tile_idx
	local bg_write_offset = chunk.bg_tile_idx
	local source_bg = chunk.bg
	
	if (tile == 256) tile = 0
	if (tile == 258 and rnd(3)<1) then
		tile += flr(rnd(6)) * 8 + (flr(rnd(8)) << 13)
	end
	
	-- Foreground tile decided by this point
	local is_foreground_transparent = tile == 0 or fget(tile, 7)
	RENDER_CHUNK_HEAP:set( write_offset+ix, iy, tile )
	
	-- Picking background tile...
	local bg_tile = is_foreground_transparent and 256+source_bg:get(ix,iy) or 0
	if (bg_tile == 256) bg_tile = 0
	if (bg_tile == 265 and rnd(3)<1) then
		bg_tile += flr(rnd(6)) * 8 + (flr(rnd(8)) << 13)
	end
	RENDER_CHUNK_HEAP:set( bg_write_offset+ix, iy, bg_tile )
end

function get_chunk_fname(cx, cy)
	return SAVEGAME_DIRECTORY .. "/" .. WORLD_NAME .. "/" .. cx .. "_" .. cy .. "-chunk.pod"
end

function chunk.free_chunk(c)
	ALLOCATION_TABLE[c.alloc_idx] = false
	ALLOCATION_TABLE[c.bg_alloc_idx] = false
	ALLOCATION_TABLE[c.light_alloc_idx] = false
	LOADED_CHUNKS[c.own_id] = nil
	if c.changed then
		CHUNKS_TO_SAVE[#CHUNKS_TO_SAVE+1] = c
	end
end

function chunk.get_chunk_by_world_pos(x,y)
	return chunk.get_chunk(flr(x/CHUNK_SIZE),flr(y/CHUNK_SIZE))
end

function chunk.get_chunk(cx,cy)
	local chunk_id = cx .. "_" .. cy
	return LOADED_CHUNKS[chunk_id]
end

function chunk.render_loaded_chunks(base_x,base_y)
	if ( key("tab") and key("shift") ) map() return
	bar_start("Rendering")
	for i,c in pairs(LOADED_CHUNKS) do
		if (c.rendered) then
			map(
				c.bg_tile_idx,  --tile_x,       starting tiles
			   0,         	 --tile_y, 
				c.screen_x,  --[sx,          screen position
				c.screen_y,  --sy], 
				CHUNK_SIZE,  --[tiles_x,     how much to draw 
				CHUNK_SIZE,  --tiles_y], 
				0x00,        --[p8layers],   p8 layers...
				8,           --[tile_w,      tile size
				8            --tile_h]
			)
			map(
				c.tile_idx,  --tile_x,       starting tiles
			   0,         	 --tile_y, 
				c.screen_x,  --[sx,          screen position
				c.screen_y,  --sy], 
				CHUNK_SIZE,  --[tiles_x,     how much to draw 
				CHUNK_SIZE,  --tiles_y], 
				0x00,        --[p8layers],   p8 layers...
				8,           --[tile_w,      tile size
				8            --tile_h]
			)
			if (key "tab" and key "l" ) then
				print(c.debug_label or "", c.screen_x, c.screen_y, 7)
				for ix=0,CHUNK_SIZE-1 do
					for iy=0,CHUNK_SIZE-1 do
						print(c.light:get(ix,iy), c.screen_x + ix * 8, c.screen_y + iy*8)
					end
				end 
			end
		end
	end
	bar_end("Rendering")

end

function chunk.render_light(base_x,base_y)
	-- if true then return end
	if ( key("tab") and key("shift") ) map() return
	bar_start("Rendering")
	for i,c in pairs(LOADED_CHUNKS) do
		if (c.rendered) then
			map(
				c.light_tile_idx,  --tile_x,       starting tiles
			   0,         	 --tile_y, 
				c.screen_x,  --[sx,          screen position
				c.screen_y,  --sy], 
				CHUNK_SIZE,  --[tiles_x,     how much to draw 
				CHUNK_SIZE,  --tiles_y], 
				0x00,        --[p8layers],   p8 layers...
				8,           --[tile_w,      tile size
				8            --tile_h]
			)
			if (key("tab")) then
				print(c.debug_label, c.screen_x, c.screen_y, 7) 
				print(c.x .. ' ' .. c.y, c.screen_x, c.screen_y+8, 7)
			end
		end
	end
	bar_end("Rendering")
end

function chunk.load_chunk(cx,cy)
	local filename = get_chunk_fname(cx, cy)
	local type, size, path = fstat(filename)
	local new_chunk = nil
	yield()
	if type then
		-- Load from disk...
		new_chunk = chunk.build_chunk()
		local data = fetch(filename)
		new_chunk.tiles = data.tiles
		new_chunk.bg = data.bg
		new_chunk.light = data.light
		new_chunk.light_sources = data.light_sources
		new_chunk.debug_label = "Loaded"
	else
		-- Generate...
		new_chunk = do_world_generation(cx,cy)
		new_chunk.changed = true
		new_chunk.debug_label = "Generated"
	end
	new_chunk.loaded_at_x = cx
	new_chunk.loaded_at_y = cy
	return new_chunk
end

local my_requests = {}
function chunk.request_load(cx,cy)
	local cid = cx .. "/" .. cy
	for i,v in pairs(my_requests) do
		if v == cid then return end
	end
	my_requests[#my_requests+1] = cid
	send_message(CHUNK_PROCESS, { event = "request_load", payload = { cx = cx, cy = cy }  })
end

function chunk.start_loader_routine() 
	return cocreate(function() 
		while true do
			aggro_loader()
		end
	end)
end

function aggro_loader()
	local loader_area_start_x = flr(center_x/CHUNK_SIZE_IN_PIXELS) - 1
	local loader_area_start_y = flr(center_y/CHUNK_SIZE_IN_PIXELS) - 1
	local loader_area_end_x   = loader_area_start_x + 9
	local loader_area_end_y   = loader_area_start_y + 7
	
	local rendered_area_start_x = loader_area_start_x
	local rendered_area_end_x   = loader_area_end_x
	local rendered_area_start_y = loader_area_start_y
	local rendered_area_end_y   = loader_area_end_y

	for ix = loader_area_start_x, loader_area_end_x do
		yield()
		for iy = loader_area_start_y, loader_area_end_y do
			local found_chunk = chunk.get_chunk(ix, iy)
			if found_chunk then
				found_chunk.touched = true
				found_chunk.rendered =
					ix >= rendered_area_start_x and ix <= rendered_area_end_x and
					iy >= rendered_area_start_y and iy <= rendered_area_end_y 
			else
				chunk.request_load(ix, iy)
				--[[ Continue in recv... --]]
			end
		end
	end
	for i,c in pairs(LOADED_CHUNKS) do
		if c.touched then
			c.touched = false
		else
			chunk.free_chunk(c)
		end
	end
end


local LIGHT_CACHE = {}
function chunk.place_light_in_world(x,y,str)
	local owner_chunk = chunk.get_chunk_by_world_pos(x,y)
	if not owner_chunk then return end
	owner_chunk.light_sources[#owner_chunk.light_sources+1] = {
		x = x,
		y = y,
		str = str
	}
	
	local light_overlay = LIGHT_CACHE[str]
	if not light_overlay then
		light_overlay = userdata("i16", str, str)
		tracked_rect(str, str, function(ix, iy, dist, idist)
			light_overlay:set(ix, iy, -idist)
		end)
	end
	
	local affected_cx, affected_cy = owner_chunk.x, owner_chunk.y
	local affected_chunk_radius = flr(str/CHUNK_SIZE/2)
	
	local min_chunk_offset = -affected_chunk_radius
	local max_chunk_offset = affected_chunk_radius
	
	dbg("Offsets:")
	dbg(min_chunk_offset)
	dbg(max_chunk_offset)
	
	local op_id = flr(rnd(100000))
	local tile_x = x%CHUNK_SIZE
	local tile_y = y%CHUNK_SIZE
	
	local center_corner = flr(str / 2)
	
	for ricx = min_chunk_offset, max_chunk_offset do
		for ricy = min_chunk_offset, max_chunk_offset do
			local icx, icy = affected_cx+ricx, affected_cy+ricy
			local c = chunk.get_chunk(icx, icy)
			if c then
				c.debug_label = op_id
				local slice = userdata("i16",CHUNK_SIZE,CHUNK_SIZE)
				light_overlay:blit(
					slice, 
					center_corner - tile_x + ricx*CHUNK_SIZE,
					center_corner - tile_y + ricy*CHUNK_SIZE
				)
				c.light = c.light + slice
				
				chunk.update_all_light_in_chunk(c)
			end
		end
	end
end

function chunk.break_light_in_world(x,y)
	local owner_chunk = chunk.get_chunk_by_world_pos(x,y)
	if not owner_chunk then return end
	local found_sources = {} -- cba backwards iteration
	for i,v in pairs(owner_chunk.light_sources) do
		if v.x == x and v.y == y then
			found_sources[#found_sources+1] = v
			tracked_rect(v.str,v.str,function (ix, iy, dist, idist)
				chunk.mutate_light_in_world(v.x+ix, v.y+iy, -idist)
			end)
		end
	end
	for i,v in pairs(found_sources) do
		del(owner_chunk.light_sources, v)
	end
end


CHUNKS_TO_SAVE = {}

function chunk.start_saver_routine()
	return cocreate(function() 
		while true do
			aggro_saver()
			yield()
		end
	end)
end

function aggro_saver()
	local c = deli(CHUNKS_TO_SAVE)
	if c then
		chunk.request_save(c)
	end
	return c
end

function chunk.request_save(c)
	send_message(CHUNK_PROCESS, { event = "request_save", payload = c })
end

function chunk.save_to_disk(c)
		local filename = get_chunk_fname(c.x,c.y)
		local data = {
			tiles = c.tiles,
			bg = c.bg,
			light = c.light,
			light_sources = c.light_sources,
		}
		store(filename, data)
end

function save_all()
	for i,c in pairs(LOADED_CHUNKS) do
		print("Will save chunk " .. i)
		CHUNKS_TO_SAVE[#CHUNKS_TO_SAVE+1] = c
	end
	local cc = 0
	while aggro_saver() do cls() print("Saved chunk " .. cc ) cc+=1 flip() end
end

function chunk.recv_chunk(evt)
	-- error "Recv unimpl"
	local new_chunk = evt.payload
	del(my_requests, new_chunk.loaded_at_x .. "/" .. new_chunk.loaded_at_y) 
	chunk.add_chunk(new_chunk.loaded_at_x, new_chunk.loaded_at_y, new_chunk)
	new_chunk.touched = true
end
--===========--
function do_world_generation(cx,cy,y)
	local new_chunk = chunk.build_chunk()
	new_chunk.tiles, new_chunk.bg, new_chunk.light = generate_terrain(cx,cy,y)
	return new_chunk
end
:: chunkservice.lua
--[[pod_format="raw",created="2025-04-25 11:19:16",modified="2025-05-22 17:03:29",revision=581]]
include "chunk.lua"

local MAIN_PID = env().argv[1]

EVENT_QUEUE = {}
on_event("request_load", function(evt)
	local args = evt.payload
	local chunkdata = chunk.load_chunk(args.cx, args.cy)
	send_message(MAIN_PID, { event = "load_chunk", payload = chunkdata })
end)

on_event("request_save", function(evt)
	local chunkdata = evt.payload
	chunk.save_to_disk(evt.payload)
end)

function _update()
	error "Update called"
end

--[[
local tt = 0
while true do
	if tt > 999999 then
		local ps = fetch "/ram/system/processes.pod"
		local alive = false
		for i,proc in pairs(ps) do
			if proc.id == MAIN_PID then
				alive = true
			end
		end
		
		if not alive then error "Subprocess exitting!" end
	end
	yield()
end
]]
:: constants.lua
--[[pod_format="raw",created="2025-04-12 19:11:01",modified="2025-05-22 15:04:28",revision=3218]]

GAME_VERSION_STRING = "Indev 0w0"
TILE_SIZE = 8
CHUNK_SIZE = 8
CHUNK_SIZE_IN_PIXELS = TILE_SIZE * CHUNK_SIZE
SAVEGAME_DIRECTORY = "/appdata/picotron_stargazer"

GRAVITY = 0.1
MAX_FALL = 4

SCREEN_WIDTH=480
SCREEN_HEIGHT=270
SCREEN_5 = SCREEN_HEIGHT/5
SCREEN_10 = SCREEN_HEIGHT/10

WORLD_SEED=stat(86)

-- colors top to bottom
-- 0x07
-- 0x1c
-- 0x0c
-- 0x10
-- 0x01

SKY_COLORS = {
	[0]    = 0x0707,
	[SCREEN_10*1]  = 0x071c,
	[SCREEN_10*2]  = 0x1c1c,
	[SCREEN_10*3]  = 0x1c0c,
	[SCREEN_10*4]  = 0x0c0c,
	[SCREEN_10*5]  = 0x0c10,
	[SCREEN_10*6]  = 0x1010,
	[SCREEN_10*7]  = 0x1001,
	[SCREEN_10*8]  = 0x0101,
	[SCREEN_10*9] = 0x0100,
}

BOTTOM_RIGHT_PIXEL_X=479
BOTTOM_RIGHT_PIXEL_Y=269

COLOR_RAMPS = {
 -- {1,2,3,4...}
 {0, 21, 19, 20, 21, 22, 23, 24, 25,  9, 27, 16, 18, 30, 24, 1, 19, 1, 1, 21, 1, 5, 30, 2, 24, 27,  3, 29, 13,  2,  4},
 {0,  0, 21, 21,  0, 21, 30, 21, 24, 25, 19,  1,  1,  2,  2, 0,  1, 0, 0,  1, 0, 0,  2, 0,  2,  3, 19, 18, 18,  1, 20},
 {0,  0,  0,  0,  0,  1,  1,  0, 21,  2,  1,  0,  0,  1, 21, 0,  0, 0, 0,  0, 0, 0,  1, 0, 21, 19,  1,  1,  1,  0, 21}
 -- {0,0,0,0...}
}


:: entity.lua
--[[pod_format="raw",created="2025-04-14 16:32:59",modified="2025-05-22 17:03:29",revision=1897]]

include "constants.lua"
include "chunk.lua"



ENTITIES = {}
function update_entities()
	if real_count(LOADED_CHUNKS) >= 80 then
		for e in all(ENTITIES) do
			e:update()
			move_entity(e)
		end
	end
end

function draw_entities(camera_x, camera_y)
	for e in all(ENTITIES) do
		camera(camera_x-flr(e.x),camera_y-flr(e.y))
		e:draw()
	end
	camera(camera_x, camera_y)
end

function add_entity(e)
	ENTITIES[#ENTITIES+1] = e
end

function is_tile_solid(x,y)
	local tile_number = chunk.get_tile_in_world(x,y)
	return tile_number and tile_number > 0
end

function move_entity(e)
    -- Horizontal movement
    e.x += e.dx
    local tile_size = TILE_SIZE
    
    -- X collision check
    local x_side = e.dx > 0 and (e.x + e.width*tile_size) or e.x
    local tx = flr(x_side/tile_size)
    local ty_start = flr(e.y/tile_size)
    local ty_end = flr((e.y + e.height*tile_size - 1)/tile_size)
    
    for ty=ty_start,ty_end do
        if is_tile_solid(tx, ty) then
            e.x = e.dx > 0 and (tx*tile_size - e.width*tile_size) or (tx+1)*tile_size
            e.dx = 0
            break
        end
    end
    
    -- Vertical movement
    -- Apply gravity
    e.dy = mid(-MAX_FALL, e.dy + GRAVITY, MAX_FALL)
    e.y += e.dy
    e.grounded = false
    
    -- Y collision check
    local y_side = e.dy > 0 and (e.y + e.height*tile_size) or e.y
    local ty = flr(y_side/tile_size)
    local tx_start = flr(e.x/tile_size)
    local tx_end = flr((e.x + e.width*tile_size - 1)/tile_size)
    
    for tx=tx_start,tx_end do
        if is_tile_solid(tx, ty) then
            e.y = e.dy > 0 and (ty*tile_size - e.height*tile_size) or (ty+1)*tile_size
            if e.dy > 0 then e.grounded = true end
            e.dy = 0
            break
        end
    end
end
:: generator.lua
--[[pod_format="raw",created="2025-04-13 21:39:41",modified="2025-05-01 09:38:46",revision=1203]]
include "noise.lua"
include "constants.lua"

local nf = simplex.Noise3D
function noise(x,y)
	return nf(x,y,n)
	+ 0.5*nf(2*x,2*y,n)
	+ 0.25*nf(4*x,4*y,n)
end

local nf = simplex.Noise3D
function noise(x,y)
	return nf(x,y,n)
	+ 0.5*nf(2*x,2*y,n)
	+ 0.25*nf(4*x,4*y,n)
end

function generate_terrain(cx,cy)
	local terrain_data = userdata("i16",CHUNK_SIZE,CHUNK_SIZE)
	local bg_data = userdata("i16",CHUNK_SIZE,CHUNK_SIZE)
	local light_data = userdata("i16",CHUNK_SIZE,CHUNK_SIZE)
	for ix=0,CHUNK_SIZE-1 do
		local world_x = cx*CHUNK_SIZE+ix
		-- Generate height data for this position of the map
		-- Sea level is at 0
		local column_height = flr(nf(world_x/64, 0xDEADBEEF, WORLD_SEED)*16)
		for iy = 0,CHUNK_SIZE-1 do
			local tile = 0
			local bg_tile = 0
			local world_y = cy*CHUNK_SIZE+iy
			local light_level = 0
			if world_y > column_height then
				light_level = min(10,world_y-column_height)
				bg_tile = 9
				tile = 2
				local cavern_noise = nf(world_x/64, world_y/64, WORLD_SEED)
					if cavern_noise > -0.1 and cavern_noise < 0.1 then
						tile = 0
					end 				
			end
			if world_y == column_height then
				bg_tile = 9
				tile = 1
			end
			
			bg_data:set(ix,iy,bg_tile)
			terrain_data:set(ix,iy,tile) 
			light_data:set(ix,iy,light_level)
		end
	end
	return terrain_data, bg_data, light_data
end

function noisetest()
	--local colors={8, 0,1,19,3,27,11,26,10,7,16}
	local colors = {7,7,7,0,7,7,7}
	function mapcol(t)
		t=max(0,min(1,t))
		local n=#colors
		return colors[flr(t*n)+1]
	end
	
	--n will be the "seed"
	n=0
	local lowest_excess = 1
	local highest_excess = 0

	while true do
		cls()

		print("HI/LO: " .. highest_excess .. "/" .. lowest_excess,0,0,7)

		for x=0,CHUNK_SIZE-1 do
			for y=0,CHUNK_SIZE-1 do
				local t = (noise(x/50,y/50)+1)/2
				if t < lowest_excess then
					lowest_excess = t
				end
				if t > highest_excess then
					highest_excess = t
				end
				
				--pset(x,y,mapcol(t))
			end
		end

		n+=1

		print(stat(1),256,0,7)	
		flip()
	end
end
:: logging.lua
--[[pod_format="raw",created="2025-04-12 21:25:08",modified="2025-04-14 21:24:47",revision=876]]
include "util.lua"

CURRENT_LOG = ""

function dbg(str)
	CURRENT_LOG ..= str .. "\n"
	CURRENT_LOG = sub(CURRENT_LOG,-1024)
end

function drawlog(x,y)
	local split_log = split(CURRENT_LOG,"\n")
	local c = 0;
	for i = max(1,#split_log-20),#split_log do
		prints(split_log[i],x,y+c*10)
		c += 1;
	end
end

function odbg(o,indent)
   if not indent then dbg('Dumping object...') end
	if type(o) == "userdata" then 
		local w,h,t = o:attribs()
		dbg(w .. "x" .. h .. " of " .. t)
		return 
	end
	if type(o) != "table" then dbg("Dumping undumpable " .. type(o) .. ": "  .. o) return end
	local indent = indent or ''
	for i,v in pairs(o) do
		if     (type(v) == 'table') then
			dbg(indent .. i .. " -> ")
			odbg(v, indent .. '  ')	
		elseif (type(v) == "function") then
			dbg("callable " .. i )
		elseif (type(v) == "userdata") then
			local w,h,t = v:attribs()
			dbg(indent .. i .. "	-> " .. w .. "x" .. h .. " of " .. t)
		else
			dbg(indent .. i .. ' = ' .. v )
		end
	end
	if indent == '' then
		dbg("Done dumping")
	end
end
:: main.lua
--[[pod_format="raw",created="2025-04-09 18:59:05",modified="2025-05-22 17:45:13",revision=4207]]
-- Picotron Stargazer
-- ~~ CREDITS ~~
-- Perlin noise implementation: github kitao -> pico8-libs -> perlin.lua

-- Todo
--[[
 [x] CHUNKS
  [x] Tracked in chunk.lua
 [x] Platformer physics and entities (Player character!)
 [ ] Light
 [ ] World interaction
 [ ] Inventory and item usage
 [ ] Interactive blocks
 [ ] Storage
 [ ] World generation I
 [ ] Gameplay goes here
 [ ] World generation II
 [ ] Final control scheme?
 [ ] Lore?
 [ ] Graphics?
 [ ] OST?
 [ ] Oleg?
]]

include "util.lua"
include "constants.lua"
include "chunk.lua"
include "logging.lua"
include "generator.lua"
include "entity.lua"
include "entities/player.lua"
include "world_interaction.lua"


local CAMERA_OFFSET_X = 0
local CAMERA_OFFSET_Y = 0
local CHUNK_X = 0
local CHUNK_Y = 0

function anitest(from,count,fskip)
	vid(3)
	local c = 0
	while true do
		cls()
		
		spr(from+c,64,64)
			print(flr(from+c),80,80)
		flip()
		local cc = 0
		while cc < fskip do cc+=1 flip() end
		c+=1
		c = c%count
	end
end

function aaa()
	anitest(2,6,5)
end


function _init()
	poke(0x550b, 0x3f)
	memcpy(0x5000+63*4,0x5000+12*4,4)
	window { cursor = 'crosshair' }
	chunk.init()
	chunk_loader = chunk.start_loader_routine()
	chunk_saver  = chunk.start_saver_routine()
	add_entity(build_player())
	
	CHUNK_PROCESS = create_process("chunkservice.lua", {argv={pid()}} )
	
	on_event("load_chunk", chunk.recv_chunk)
	
	color_table = userdata("u8", 64, 64)
	memmap(0x8000, color_table)
	for i=0,63 do
		for j=0,63 do
			color_table:set(i,j,j)
		end
	end
	for i=0,63 do
		color_table:set(i,0,i)
	end
	for k=1,3 do
		for i=1,31 do
			color_table:set(i, 32+k, COLOR_RAMPS[k][i])
		end
		color_table:set(63, 32+k, 63)
	end
end

FRAME_COUNTER = 0
function _draw()
	start_bar_frame()
	FRAME_COUNTER+=1
	cls(63)
	camera(CAMERA_OFFSET_X,CAMERA_OFFSET_Y)
	chunk.render_loaded_chunks()
	draw_entities(CAMERA_OFFSET_X, CAMERA_OFFSET_Y)
	chunk.render_light()
	draw_world_mouse()

	camera()
	
	local mem = stat(3)
	if (key('tab')) then 
		mem = stat(0)
		prints("Picotron version: "..  stat(5),1,10)
		prints("Loaded chunks: " .. real_count(LOADED_CHUNKS), 1, 20)
		drawlog(1, 30)
	end

	prints(
		"Picotron Stargazer ".. GAME_VERSION_STRING ..
		"\nTest build! Not for distribution!" ..
		"\n CS: " .. (SAVER_STATUS and "OK" or "FAIL") ..
		"   CL: " .. (LOADER_STATUS and "OK" or "FAIL")
		,1,1)
	perf_graph()
	draw_debug_bars()

end

COLOR_MAGIC = {0, 33, 34, 35, 36, 37, 36, 35, 34, 33, 0}

DEBUG_CAMERA_SPEED = 4

local load_test = 50
function _update()

	if not (key("tab") and key("p")) then
		LOADER_STATUS, LOADER_OUTPUT = coresume(chunk_loader)
		SAVER_STATUS = coresume(chunk_saver)
	end

	if	key("q") then
		save_all()
		stop("Goodbye <3")
	end
	
	update_world_mouse(CAMERA_OFFSET_X, CAMERA_OFFSET_Y)
	update_entities()

	CAMERA_OFFSET_X = ENTITIES[1].x-240---120
	CAMERA_OFFSET_Y = ENTITIES[1].y-135---67-
	chunk.set_center(CAMERA_OFFSET_X, CAMERA_OFFSET_Y)

end
:: noise-all.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0wNC0yNCAxNjoxNDo0NSIsbW9k
aWZpZWQ9IjIwMjUtMDQtMjQgMTY6MTQ6NDUiLHJldmlzaW9uPTBdXQotLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS1TaW1wbGV4IE5vaXNlCi0tIE9yaWdp
bmFsIEphdmEgU291cmNlOiBodHRwOi8vc3RhZmZ3d3cuaXRuLmxpdS5zZS9_c3RlZ3Uvc2ltcGxl
eG5vaXNlL3NpbXBsZXhub2lzZS5wZGYKLS0gKG1vc3QpIE9yaWdpbmFsIGNvbW1lbnRzIGluY2x1
ZGVkCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgpsb2Nh
bCBtYXRoID0gbWF0aApsb2NhbCB0YWJsZSA9IHRhYmxlCmxvY2FsIHRvbnVtYmVyID0gdG9udW1i
ZXIKbG9jYWwgaXBhaXJzID0gaXBhaXJzCmxvY2FsIGVycm9yID0gZXJyb3IKCnNpbXBsZXggPSB7
fQoKc2ltcGxleC5ESVJfWCA9IDAKc2ltcGxleC5ESVJfWSA9IDEKc2ltcGxleC5ESVJfWiA9IDIK
c2ltcGxleC5ESVJfVyA9IDMKc2ltcGxleC5pbnRlcm5hbENhY2hlID0gZmFsc2UKCmxvY2FsIEdy
YWRpZW50czNEID0ge3sxLDEsMH0sey0xLDEsMH0sezEsLTEsMH0sey0xLC0xLDB9LAp7MSwwLDF9
LHstMSwwLDF9LHsxLDAsLTF9LHstMSwwLC0xfSwKezAsMSwxfSx7MCwtMSwxfSx7MCwxLC0xfSx7
MCwtMSwtMX19Owpsb2NhbCBHcmFkaWVudHM0RCA9IHt7MCwxLDEsMX0sIHswLDEsMSwtMX0sIHsw
LDEsLTEsMX0sIHswLDEsLTEsLTF9LAp7MCwtMSwxLDF9LCB7MCwtMSwxLC0xfSwgezAsLTEsLTEs
MX0sIHswLC0xLC0xLC0xfSwKezEsMCwxLDF9LCB7MSwwLDEsLTF9LCB7MSwwLC0xLDF9LCB7MSww
LC0xLC0xfSwKey0xLDAsMSwxfSwgey0xLDAsMSwtMX0sIHstMSwwLC0xLDF9LCB7LTEsMCwtMSwt
MX0sCnsxLDEsMCwxfSwgezEsMSwwLC0xfSwgezEsLTEsMCwxfSwgezEsLTEsMCwtMX0sCnstMSwx
LDAsMX0sIHstMSwxLDAsLTF9LCB7LTEsLTEsMCwxfSwgey0xLC0xLDAsLTF9LAp7MSwxLDEsMH0s
IHsxLDEsLTEsMH0sIHsxLC0xLDEsMH0sIHsxLC0xLC0xLDB9LAp7LTEsMSwxLDB9LCB7LTEsMSwt
MSwwfSwgey0xLC0xLDEsMH0sIHstMSwtMSwtMSwwfX07CmxvY2FsIHAgPSB7MTUxLDE2MCwxMzcs
OTEsOTAsMTUsCjEzMSwxMywyMDEsOTUsOTYsNTMsMTk0LDIzMyw3LDIyNSwxNDAsMzYsMTAzLDMw
LDY5LDE0Miw4LDk5LDM3LDI0MCwyMSwxMCwyMywKMTkwLCA2LDE0OCwyNDcsMTIwLDIzNCw3NSww
LDI2LDE5Nyw2Miw5NCwyNTIsMjE5LDIwMywxMTcsMzUsMTEsMzIsNTcsMTc3LDMzLAo4OCwyMzcs
MTQ5LDU2LDg3LDE3NCwyMCwxMjUsMTM2LDE3MSwxNjgsIDY4LDE3NSw3NCwxNjUsNzEsMTM0LDEz
OSw0OCwyNywxNjYsCjc3LDE0NiwxNTgsMjMxLDgzLDExMSwyMjksMTIyLDYwLDIxMSwxMzMsMjMw
LDIyMCwxMDUsOTIsNDEsNTUsNDYsMjQ1LDQwLDI0NCwKMTAyLDE0Myw1NCwgNjUsMjUsNjMsMTYx
LCAxLDIxNiw4MCw3MywyMDksNzYsMTMyLDE4NywyMDgsIDg5LDE4LDE2OSwyMDAsMTk2LAoxMzUs
MTMwLDExNiwxODgsMTU5LDg2LDE2NCwxMDAsMTA5LDE5OCwxNzMsMTg2LCAzLDY0LDUyLDIxNywy
MjYsMjUwLDEyNCwxMjMsCjUsMjAyLDM4LDE0NywxMTgsMTI2LDI1NSw4Miw4NSwyMTIsMjA3LDIw
Niw1OSwyMjcsNDcsMTYsNTgsMTcsMTgyLDE4OSwyOCw0MiwKMjIzLDE4MywxNzAsMjEzLDExOSwy
NDgsMTUyLCAyLDQ0LDE1NCwxNjMsIDcwLDIyMSwxNTMsMTAxLDE1NSwxNjcsIDQzLDE3Miw5LAox
MjksMjIsMzksMjUzLCAxOSw5OCwxMDgsMTEwLDc5LDExMywyMjQsMjMyLDE3OCwxODUsIDExMiwx
MDQsMjE4LDI0Niw5NywyMjgsCjI1MSwzNCwyNDIsMTkzLDIzOCwyMTAsMTQ0LDEyLDE5MSwxNzks
MTYyLDI0MSwgODEsNTEsMTQ1LDIzNSwyNDksMTQsMjM5LDEwNywKNDksMTkyLDIxNCwgMzEsMTgx
LDE5OSwxMDYsMTU3LDE4NCwgODQsMjA0LDE3NiwxMTUsMTIxLDUwLDQ1LDEyNywgNCwxNTAsMjU0
LAoxMzgsMjM2LDIwNSw5MywyMjIsMTE0LDY3LDI5LDI0LDcyLDI0MywxNDEsMTI4LDE5NSw3OCw2
NiwyMTUsNjEsMTU2LDE4MH07CgotLSBUbyByZW1vdmUgdGhlIG5lZWQgZm9yIGluZGV4IHdyYXBw
aW5nLCBkb3VibGUgdGhlIHBlcm11dGF0aW9uIHRhYmxlIGxlbmd0aAoKZm9yIGk9MSwjcCBkbwoJ
cFtpLTFdID0gcFtpXQoJcFtpXSA9IG5pbAplbmQKCmZvciBpPTEsI0dyYWRpZW50czNEIGRvCglH
cmFkaWVudHMzRFtpLTFdID0gR3JhZGllbnRzM0RbaV0KCUdyYWRpZW50czNEW2ldID0gbmlsCmVu
ZAoKZm9yIGk9MSwjR3JhZGllbnRzNEQgZG8KCUdyYWRpZW50czREW2ktMV0gPSBHcmFkaWVudHM0
RFtpXQoJR3JhZGllbnRzNERbaV0gPSBuaWwKZW5kCgpsb2NhbCBwZXJtID0ge30KCmZvciBpPTAs
MjU1IGRvCglwZXJtW2ldID0gcFtpXQoJcGVybVtpKzI1Nl0gPSBwW2ldCmVuZAoKLS0gQSBsb29r
dXAgdGFibGUgdG8gdHJhdmVyc2UgdGhlIHNpbSBhcm91bmQgYSBnaXZlbiBwb2ludCBpbiA0RC4K
LS0gRGV0YWlscyBjYW4gYmUgZm91bmQgd2hlcmUgdGhpcyB0YWJsZSBpcyB1c2VkLCBpbiB0aGUg
NEQgbm9pc2UgbWV0aG9kLgoKbG9jYWwgc2ltID0gewp7MCwxLDIsM30sezAsMSwzLDJ9LHswLDAs
MCwwfSx7MCwyLDMsMX0sezAsMCwwLDB9LHswLDAsMCwwfSx7MCwwLDAsMH0sezEsMiwzLDB9LAp7
MCwyLDEsM30sezAsMCwwLDB9LHswLDMsMSwyfSx7MCwzLDIsMX0sezAsMCwwLDB9LHswLDAsMCww
fSx7MCwwLDAsMH0sezEsMywyLDB9LAp7MCwwLDAsMH0sezAsMCwwLDB9LHswLDAsMCwwfSx7MCww
LDAsMH0sezAsMCwwLDB9LHswLDAsMCwwfSx7MCwwLDAsMH0sezAsMCwwLDB9LAp7MSwyLDAsM30s
ezAsMCwwLDB9LHsxLDMsMCwyfSx7MCwwLDAsMH0sezAsMCwwLDB9LHswLDAsMCwwfSx7MiwzLDAs
MX0sezIsMywxLDB9LAp7MSwwLDIsM30sezEsMCwzLDJ9LHswLDAsMCwwfSx7MCwwLDAsMH0sezAs
MCwwLDB9LHsyLDAsMywxfSx7MCwwLDAsMH0sezIsMSwzLDB9LAp7MCwwLDAsMH0sezAsMCwwLDB9
LHswLDAsMCwwfSx7MCwwLDAsMH0sezAsMCwwLDB9LHswLDAsMCwwfSx7MCwwLDAsMH0sezAsMCww
LDB9LAp7MiwwLDEsM30sezAsMCwwLDB9LHswLDAsMCwwfSx7MCwwLDAsMH0sezMsMCwxLDJ9LHsz
LDAsMiwxfSx7MCwwLDAsMH0sezMsMSwyLDB9LAp7MiwxLDAsM30sezAsMCwwLDB9LHswLDAsMCww
fSx7MCwwLDAsMH0sezMsMSwwLDJ9LHswLDAsMCwwfSx7MywyLDAsMX0sezMsMiwxLDB9fTsKCmxv
Y2FsIGZ1bmN0aW9uIERvdDJEKHRibCwgeCwgeSkKCXJldHVybiB0YmxbMV0qeCArIHRibFsyXSp5
OyAKZW5kCgpsb2NhbCBmdW5jdGlvbiBEb3QzRCh0YmwsIHgsIHksIHopCglyZXR1cm4gdGJsWzFd
KnggKyB0YmxbMl0qeSArIHRibFszXSp6CmVuZAoKbG9jYWwgZnVuY3Rpb24gRG90NEQoIHRibCwg
eCx5LHosdykgCglyZXR1cm4gdGJsWzFdKnggKyB0YmxbMl0qeSArIHRibFszXSp6ICsgdGJsWzNd
Knc7CmVuZAoKbG9jYWwgUHJldjJEID0ge30KCi0tIDJEIHNpbXBsZXggbm9pc2UKCmZ1bmN0aW9u
IHNpbXBsZXguTm9pc2UyRCh4aW4sIHlpbikKCWlmIHNpbXBsZXguaW50ZXJuYWxDYWNoZSBhbmQg
UHJldjJEW3hpbl0gYW5kIFByZXYyRFt4aW5dW3lpbl0gdGhlbiByZXR1cm4gUHJldjJEW3hpbl1b
eWluXSBlbmQgCgoJbG9jYWwgbjAsIG4xLCBuMjsgLS0gTm9pc2UgY29udHJpYnV0aW9ucyBmcm9t
IHRoZSB0aHJlZSBjb3JuZXJzCgktLSBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUg
d2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluCglsb2NhbCBGMiA9IDAuNSoobWF0aC5zcXJ0KDMu
MCktMS4wKTsKCWxvY2FsIHMgPSAoeGluK3lpbikqRjI7IC0tIEhhaXJ5IGZhY3RvciBmb3IgMkQK
CWxvY2FsIGkgPSBtYXRoLmZsb29yKHhpbitzKTsKCWxvY2FsIGogPSBtYXRoLmZsb29yKHlpbitz
KTsKCWxvY2FsIEcyID0gKDMuMC1tYXRoLnNxcnQoMy4wKSkvNi4wOwoKCWxvY2FsIHQgPSAoaStq
KSpHMjsKCWxvY2FsIFgwID0gaS10OyAtLSBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sgdG8g
KHgseSkgc3BhY2UKCWxvY2FsIFkwID0gai10OwoJbG9jYWwgeDAgPSB4aW4tWDA7IC0tIFRoZSB4
LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luCglsb2NhbCB5MCA9IHlpbi1ZMDsKCgkt
LSBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRy
aWFuZ2xlLgoJLS0gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLgoJbG9jYWwgaTEs
IGoxOyAtLSBPZmZzZXRzIGZvciBzZWNvbmQgKG1pZGRsZSkgY29ybmVyIG9mIHNpbXBsZXggaW4g
KGksaikgY29vcmRzCglpZih4MD55MCkgdGhlbiAKCQlpMT0xIAoJCWoxPTAgIC0tIGxvd2VyIHRy
aWFuZ2xlLCBYWSBvcmRlcjogKDAsMCktPigxLDApLT4oMSwxKQoJZWxzZQoJCWkxPTAKCQlqMT0x
IC0tIHVwcGVyIHRyaWFuZ2xlLCBZWCBvcmRlcjogKDAsMCktPigwLDEpLT4oMSwxKQoJZW5kCgoJ
LS0gQSBzdGVwIG9mICgxLDApIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jKSBpbiAo
eCx5KSwgYW5kCgktLSBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9mICgt
YywxLWMpIGluICh4LHkpLCB3aGVyZQoJLS0gYyA9ICgzLXNxcnQoMykpLzYKCglsb2NhbCB4MSA9
IHgwIC0gaTEgKyBHMjsgLS0gT2Zmc2V0cyBmb3IgbWlkZGxlIGNvcm5lciBpbiAoeCx5KSB1bnNr
ZXdlZCBjb29yZHMKCWxvY2FsIHkxID0geTAgLSBqMSArIEcyOwoJbG9jYWwgeDIgPSB4MCAtIDEu
MCArIDIuMCAqIEcyOyAtLSBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5KSB1bnNrZXdl
ZCBjb29yZHMKCWxvY2FsIHkyID0geTAgLSAxLjAgKyAyLjAgKiBHMjsKCgktLSBXb3JrIG91dCB0
aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIHRocmVlIHNpbXBsZXggY29ybmVycwoJ
bG9jYWwgaWkgPSBpJjI1NQoJbG9jYWwgamogPSBqJjI1NQoJbG9jYWwgZ2kwID0gcGVybVtpaStw
ZXJtW2pqXV0gJSAxMjsKCWxvY2FsIGdpMSA9IHBlcm1baWkraTErcGVybVtqaitqMV1dICUgMTI7
Cglsb2NhbCBnaTIgPSBwZXJtW2lpKzErcGVybVtqaisxXV0gJSAxMjsKCgktLSBDYWxjdWxhdGUg
dGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzCglsb2NhbCB0MCA9IDAuNSAt
IHgwKngwLXkwKnkwOwoJaWYgdDA8MCB0aGVuIAoJCW4wID0gMC4wOwoJZWxzZQoJCXQwID0gdDAg
KiB0MAoJCW4wID0gdDAgKiB0MCAqIERvdDJEKEdyYWRpZW50czNEW2dpMF0sIHgwLCB5MCk7IC0t
ICh4LHkpIG9mIEdyYWRpZW50czNEIHVzZWQgZm9yIDJEIGdyYWRpZW50CgllbmQKCglsb2NhbCB0
MSA9IDAuNSAtIHgxKngxLXkxKnkxOwoJaWYgKHQxPDApIHRoZW4KCQluMSA9IDAuMDsKCWVsc2UK
CQl0MSA9IHQxKnQxCgkJbjEgPSB0MSAqIHQxICogRG90MkQoR3JhZGllbnRzM0RbZ2kxXSwgeDEs
IHkxKTsKCWVuZAoKCWxvY2FsIHQyID0gMC41IC0geDIqeDIteTIqeTI7CglpZiAodDI8MCkgdGhl
bgoJCW4yID0gMC4wOwoJZWxzZQoJCXQyID0gdDIqdDIKCQluMiA9IHQyICogdDIgKiBEb3QyRChH
cmFkaWVudHMzRFtnaTJdLCB4MiwgeTIpOwoJZW5kCgoJLS0gQWRkIGNvbnRyaWJ1dGlvbnMgZnJv
bSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLgoJLS0gVGhlIHJlc3Vs
dCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgbG9jYWxlcnZhbCBbLTEsMV0uCgoJ
bG9jYWwgcmV0dmFsID0gNzAuMCAqIChuMCArIG4xICsgbjIpCgoJaWYgc2ltcGxleC5pbnRlcm5h
bENhY2hlIHRoZW4KCQlpZiBub3QgUHJldjJEW3hpbl0gdGhlbiBQcmV2MkRbeGluXSA9IHt9IGVu
ZAoJCVByZXYyRFt4aW5dW3lpbl0gPSByZXR2YWwKCWVuZAoKCXJldHVybiByZXR2YWw7CmVuZAoK
bG9jYWwgUHJldjNEID0ge30KCi0tIDNEIHNpbXBsZXggbm9pc2UKZnVuY3Rpb24gc2ltcGxleC5O
b2lzZTNEKHhpbiwgeWluLCB6aW4pCgoJbG9jYWwgbjAsIG4xLCBuMiwgbjM7IC0tIE5vaXNlIGNv
bnRyaWJ1dGlvbnMgZnJvbSB0aGUgZm91ciBjb3JuZXJzCgoJLS0gU2tldyB0aGUgaW5wdXQgc3Bh
Y2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpbgoJbG9jYWwgRjMgPSAx
LjAvMy4wOwoJbG9jYWwgcyA9ICh4aW4reWluK3ppbikqRjM7IC0tIFZlcnkgbmljZSBhbmQgc2lt
cGxlIHNrZXcgZmFjdG9yIGZvciAzRAoJbG9jYWwgaSA9IG1hdGguZmxvb3IoeGluK3MpOwoJbG9j
YWwgaiA9IG1hdGguZmxvb3IoeWluK3MpOwoJbG9jYWwgayA9IG1hdGguZmxvb3IoemluK3MpOwoK
CWxvY2FsIEczID0gMS4wLzYuMDsgLS0gVmVyeSBuaWNlIGFuZCBzaW1wbGUgdW5za2V3IGZhY3Rv
ciwgdG9vCglsb2NhbCB0ID0gKGkraitrKSpHMzsKCglsb2NhbCBYMCA9IGktdDsgLS0gVW5za2V3
IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseikgc3BhY2UKCWxvY2FsIFkwID0gai10OwoJ
bG9jYWwgWjAgPSBrLXQ7CgoJbG9jYWwgeDAgPSB4aW4tWDA7IC0tIFRoZSB4LHkseiBkaXN0YW5j
ZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW4KCWxvY2FsIHkwID0geWluLVkwOwoJbG9jYWwgejAgPSB6
aW4tWjA7CgoJLS0gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdo
dGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi4KCS0tIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdl
IGFyZSBpbi4KCWxvY2FsIGkxLCBqMSwgazE7IC0tIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIg
b2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3JkcwoJbG9jYWwgaTIsIGoyLCBrMjsgLS0gT2Zmc2V0
cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHMKCglpZiAoeDA_
PXkwKSB0aGVuCgkJaWYgKHkwPj16MCkgdGhlbgoJCQlpMT0xOyBqMT0wOyBrMT0wOyBpMj0xOyBq
Mj0xOyBrMj0wOyAtLSBYIFkgWiBvcmRlcgoJCWVsc2VpZiAoeDA_PXowKSB0aGVuCgkJCWkxPTE7
IGoxPTA7IGsxPTA7IGkyPTE7IGoyPTA7IGsyPTE7IC0tIFggWiBZIG9yZGVyCgkJZWxzZSAKCQkJ
aTE9MDsgajE9MDsgazE9MTsgaTI9MTsgajI9MDsgazI9MTsgIC0tIFogWCBZIG9yZGVyCgkJZW5k
CgllbHNlIC0tIHgwPHkwCgkJaWYgKHkwPHowKSB0aGVuIAoJCQlpMT0wOyBqMT0wOyBrMT0xOyBp
Mj0wOyBqMj0xOyBrMj0xOyAtLSBaIFkgWCBvcmRlcgoJCWVsc2VpZiAoeDA8ejApIHRoZW4gCgkJ
CWkxPTA7IGoxPTE7IGsxPTA7IGkyPTA7IGoyPTE7IGsyPTE7IC0tIFkgWiBYIG9yZGVyCgkJZWxz
ZSAKCQkJaTE9MDsgajE9MTsgazE9MDsgaTI9MTsgajI9MTsgazI9MDsgLS0gWSBYIFogb3JkZXIK
CQllbmQKCWVuZAoKCS0tIEEgc3RlcCBvZiAoMSwwLDApIGluIChpLGosaykgbWVhbnMgYSBzdGVw
IG9mICgxLWMsLWMsLWMpIGluICh4LHkseiksCgktLSBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxq
LGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmQKCS0tIGEgc3Rl
cCBvZiAoMCwwLDEpIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgtYywtYywxLWMpIGluICh4
LHkseiksIHdoZXJlCgktLSBjID0gMS82LgoKCWxvY2FsIHgxID0geDAgLSBpMSArIEczOyAtLSBP
ZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseikgY29vcmRzCglsb2NhbCB5MSA9IHkw
IC0gajEgKyBHMzsKCWxvY2FsIHoxID0gejAgLSBrMSArIEczOwoKCWxvY2FsIHgyID0geDAgLSBp
MiArIDIuMCpHMzsgLS0gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseikgY29vcmRz
Cglsb2NhbCB5MiA9IHkwIC0gajIgKyAyLjAqRzM7Cglsb2NhbCB6MiA9IHowIC0gazIgKyAyLjAq
RzM7CgoJbG9jYWwgeDMgPSB4MCAtIDEuMCArIDMuMCpHMzsgLS0gT2Zmc2V0cyBmb3IgbGFzdCBj
b3JuZXIgaW4gKHgseSx6KSBjb29yZHMKCWxvY2FsIHkzID0geTAgLSAxLjAgKyAzLjAqRzM7Cgls
b2NhbCB6MyA9IHowIC0gMS4wICsgMy4wKkczOwoKCS0tIFdvcmsgb3V0IHRoZSBoYXNoZWQgZ3Jh
ZGllbnQgaW5kaWNlcyBvZiB0aGUgZm91ciBzaW1wbGV4IGNvcm5lcnMKCWxvY2FsIGlpID0gaSYy
NTUKCWxvY2FsIGpqID0gaiYyNTUKCWxvY2FsIGtrID0gayYyNTUKCglsb2NhbCBnaTAgPSBwZXJt
W2lpK3Blcm1bamorcGVybVtra11dXSAlIDEyOwoJbG9jYWwgZ2kxID0gcGVybVtpaStpMStwZXJt
W2pqK2oxK3Blcm1ba2srazFdXV0gJSAxMjsKCWxvY2FsIGdpMiA9IHBlcm1baWkraTIrcGVybVtq
aitqMitwZXJtW2trK2syXV1dICUgMTI7Cglsb2NhbCBnaTMgPSBwZXJtW2lpKzErcGVybVtqaisx
K3Blcm1ba2srMV1dXSAlIDEyOwoKCS0tIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20g
dGhlIGZvdXIgY29ybmVycwoJbG9jYWwgdDAgPSAwLjUgLSB4MCp4MCAtIHkwKnkwIC0gejAqejA7
CgoJaWYgKHQwPDApIHRoZW4KCQluMCA9IDAuMDsKCWVsc2UgCgkJdDAgPSB0MCp0MDsKCQluMCA9
IHQwICogdDAgKiBEb3QzRChHcmFkaWVudHMzRFtnaTBdLCB4MCwgeTAsIHowKTsKCWVuZAoKCWxv
Y2FsIHQxID0gMC41IC0geDEqeDEgLSB5MSp5MSAtIHoxKnoxOwoKCWlmICh0MTwwKSB0aGVuIAoJ
CW4xID0gMC4wOwoJZWxzZQoJCXQxID0gdDEqdDE7CgkJbjEgPSB0MSAqIHQxICogRG90M0QoR3Jh
ZGllbnRzM0RbZ2kxXSwgeDEsIHkxLCB6MSk7CgllbmQKCglsb2NhbCB0MiA9IDAuNSAtIHgyKngy
IC0geTIqeTIgLSB6Mip6MjsKCglpZiAodDI8MCkgdGhlbiAKCQluMiA9IDAuMDsKCWVsc2UKCQl0
MiA9IHQyKnQyOwoJCW4yID0gdDIgKiB0MiAqIERvdDNEKEdyYWRpZW50czNEW2dpMl0sIHgyLCB5
MiwgejIpOwoJZW5kCgoJbG9jYWwgdDMgPSAwLjUgLSB4Myp4MyAtIHkzKnkzIC0gejMqejM7CgoJ
aWYgKHQzPDApIHRoZW4gCgkJbjMgPSAwLjA7CgllbHNlCgkJdDMgPSB0Myp0MzsKCQluMyA9IHQz
ICogdDMgKiBEb3QzRChHcmFkaWVudHMzRFtnaTNdLCB4MywgeTMsIHozKTsKCWVuZAoKCS0tIEFk
ZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2
YWx1ZS4KCS0tIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHN0YXkganVzdCBpbnNpZGUgWy0xLDFd
Cglsb2NhbCByZXR2YWwgPSA0NiAqIChuMCArIG4xICsgbjIgKyBuMykKCglyZXR1cm4gcmV0dmFs
OwplbmQKCmxvY2FsIFByZXY0RCA9IHt9CgotLSA0RCBzaW1wbGV4IG5vaXNlCmZ1bmN0aW9uIHNp
bXBsZXguTm9pc2U0RCh4LHkseix3KQoKCWlmIHNpbXBsZXguaW50ZXJuYWxDYWNoZSBhbmQgUHJl
djREW3hdIGFuZCBQcmV2NERbeF1beV0gYW5kIFByZXY0RFt4XVt5XVt6XSBhbmQgUHJldjREW3hd
W3ldW3pdW3ddIHRoZW4gcmV0dXJuIFByZXY0RFt4XVt5XVt6XVt3XSBlbmQKCgktLSBUaGUgc2tl
d2luZyBhbmQgdW5za2V3aW5nIGZhY3RvcnMgYXJlIGhhaXJ5IGFnYWluIGZvciB0aGUgNEQgY2Fz
ZQoJbG9jYWwgRjQgPSAobWF0aC5zcXJ0KDUuMCktMS4wKS80LjA7Cglsb2NhbCBHNCA9ICg1LjAt
bWF0aC5zcXJ0KDUuMCkpLzIwLjA7Cglsb2NhbCBuMCwgbjEsIG4yLCBuMywgbjQ7IC0tIE5vaXNl
IGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzCgktLSBTa2V3IHRoZSAoeCx5LHos
dykgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGNlbGwgb2YgMjQgc2ltcGxpY2VzIHdlJ3JlIGlu
Cglsb2NhbCBzID0gKHggKyB5ICsgeiArIHcpICogRjQ7IC0tIEZhY3RvciBmb3IgNEQgc2tld2lu
ZwoJbG9jYWwgaSA9IG1hdGguZmxvb3IoeCArIHMpOwoJbG9jYWwgaiA9IG1hdGguZmxvb3IoeSAr
IHMpOwoJbG9jYWwgayA9IG1hdGguZmxvb3IoeiArIHMpOwoJbG9jYWwgbCA9IG1hdGguZmxvb3Io
dyArIHMpOwoJbG9jYWwgdCA9IChpICsgaiArIGsgKyBsKSAqIEc0OyAtLSBGYWN0b3IgZm9yIDRE
IHVuc2tld2luZwoJbG9jYWwgWDAgPSBpIC0gdDsgLS0gVW5za2V3IHRoZSBjZWxsIG9yaWdpbiBi
YWNrIHRvICh4LHkseix3KSBzcGFjZQoJbG9jYWwgWTAgPSBqIC0gdDsKCWxvY2FsIFowID0gayAt
IHQ7Cglsb2NhbCBXMCA9IGwgLSB0OwoJbG9jYWwgeDAgPSB4IC0gWDA7IC0tIFRoZSB4LHkseix3
IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpbgoJbG9jYWwgeTAgPSB5IC0gWTA7Cglsb2Nh
bCB6MCA9IHogLSBaMDsKCWxvY2FsIHcwID0gdyAtIFcwOwoJLS0gRm9yIHRoZSA0RCBjYXNlLCB0
aGUgc2ltcGxleCBpcyBhIDREIHNoYXBlIEkgd29uJ3QgZXZlbiB0cnkgdG8gZGVzY3JpYmUuCgkt
LSBUbyBmaW5kIG91dCB3aGljaCBvZiB0aGUgMjQgcG9zc2libGUgc2ltcGxpY2VzIHdlJ3JlIGlu
LCB3ZSBuZWVkIHRvCgktLSBkZXRlcm1pbmUgdGhlIG1hZ25pdHVkZSBvcmRlcmluZyBvZiB4MCwg
eTAsIHowIGFuZCB3MC4KCS0tIFRoZSBtZXRob2QgYmVsb3cgaXMgYSBnb29kIHdheSBvZiBmaW5k
aW5nIHRoZSBvcmRlcmluZyBvZiB4LHkseix3IGFuZAoJLS0gdGhlbiBmaW5kIHRoZSBjb3JyZWN0
IHRyYXZlcnNhbCBvcmRlciBmb3IgdGhlIHNpbXBsZXggd2Xvv71yZSBpbi4KCS0tIEZpcnN0LCBz
aXggcGFpci13aXNlIGNvbXBhcmlzb25zIGFyZSBwZXJmb3JtZWQgYmV0d2VlbiBlYWNoIHBvc3Np
YmxlIHBhaXIKCS0tIG9mIHRoZSBmb3VyIGNvb3JkaW5hdGVzLCBhbmQgdGhlIHJlc3VsdHMgYXJl
IHVzZWQgdG8gYWRkIHVwIGJpbmFyeSBiaXRzCgktLSBmb3IgYW4gbG9jYWxlZ2VyIGluZGV4LgoJ
bG9jYWwgYzEgPSAoeDAgPiB5MCkgYW5kIDMyIG9yIDE7Cglsb2NhbCBjMiA9ICh4MCA_IHowKSBh
bmQgMTYgb3IgMTsKCWxvY2FsIGMzID0gKHkwID4gejApIGFuZCA4IG9yIDE7Cglsb2NhbCBjNCA9
ICh4MCA_IHcwKSBhbmQgNCBvciAxOwoJbG9jYWwgYzUgPSAoeTAgPiB3MCkgYW5kIDIgb3IgMTsK
CWxvY2FsIGM2ID0gKHowID4gdzApIGFuZCAxIG9yIDE7Cglsb2NhbCBjID0gYzEgKyBjMiArIGMz
ICsgYzQgKyBjNSArIGM2OwoJbG9jYWwgaTEsIGoxLCBrMSwgbDE7IC0tIFRoZSBsb2NhbGVnZXIg
b2Zmc2V0cyBmb3IgdGhlIHNlY29uZCBzaW1wbGV4IGNvcm5lcgoJbG9jYWwgaTIsIGoyLCBrMiwg
bDI7IC0tIFRoZSBsb2NhbGVnZXIgb2Zmc2V0cyBmb3IgdGhlIHRoaXJkIHNpbXBsZXggY29ybmVy
Cglsb2NhbCBpMywgajMsIGszLCBsMzsgLS0gVGhlIGxvY2FsZWdlciBvZmZzZXRzIGZvciB0aGUg
Zm91cnRoIHNpbXBsZXggY29ybmVyCgoJLS0gc2ltW2NdIGlzIGEgNC12ZWN0b3Igd2l0aCB0aGUg
bnVtYmVycyAwLCAxLCAyIGFuZCAzIGluIHNvbWUgb3JkZXIuCgktLSBNYW55IHZhbHVlcyBvZiBj
IHdpbGwgbmV2ZXIgb2NjdXIsIHNpbmNlIGUuZy4geD55Pno_dyBtYWtlcyB4PHosIHk8dyBhbmQg
eDx3CgktLSBpbXBvc3NpYmxlLiBPbmx5IHRoZSAyNCBpbmRpY2VzIHdoaWNoIGhhdmUgbm9uLXpl
cm8gZW50cmllcyBtYWtlIGFueSBzZW5zZS4KCS0tIFdlIHVzZSBhIHRocmVzaG9sZGluZyB0byBz
ZXQgdGhlIGNvb3JkaW5hdGVzIGluIHR1cm4gZnJvbSB0aGUgbGFyZ2VzdCBtYWduaXR1ZGUuCgkt
LSBUaGUgbnVtYmVyIDMgaW4gdGhlICJzaW0iIGFycmF5IGlzIGF0IHRoZSBwb3NpdGlvbiBvZiB0
aGUgbGFyZ2VzdCBjb29yZGluYXRlLgoKCWkxID0gc2ltW2NdWzFdPj0zIGFuZCAxIG9yIDA7Cglq
MSA9IHNpbVtjXVsyXT49MyBhbmQgMSBvciAwOwoJazEgPSBzaW1bY11bM10_PTMgYW5kIDEgb3Ig
MDsKCWwxID0gc2ltW2NdWzRdPj0zIGFuZCAxIG9yIDA7CgktLSBUaGUgbnVtYmVyIDIgaW4gdGhl
ICJzaW0iIGFycmF5IGlzIGF0IHRoZSBzZWNvbmQgbGFyZ2VzdCBjb29yZGluYXRlLgoJaTIgPSBz
aW1bY11bMV0_PTIgYW5kIDEgb3IgMDsKCWoyID0gc2ltW2NdWzJdPj0yIGFuZCAxIG9yIDA7Cglr
MiA9IHNpbVtjXVszXT49MiBhbmQgMSBvciAwOwoJbDIgPSBzaW1bY11bNF0_PTIgYW5kIDEgb3Ig
MDsKCS0tIFRoZSBudW1iZXIgMSBpbiB0aGUgInNpbSIgYXJyYXkgaXMgYXQgdGhlIHNlY29uZCBz
bWFsbGVzdCBjb29yZGluYXRlLgoJaTMgPSBzaW1bY11bMV0_PTEgYW5kIDEgb3IgMDsKCWozID0g
c2ltW2NdWzJdPj0xIGFuZCAxIG9yIDA7CglrMyA9IHNpbVtjXVszXT49MSBhbmQgMSBvciAwOwoJ
bDMgPSBzaW1bY11bNF0_PTEgYW5kIDEgb3IgMDsKCS0tIFRoZSBmaWZ0aCBjb3JuZXIgaGFzIGFs
bCBjb29yZGluYXRlIG9mZnNldHMgPSAxLCBzbyBubyBuZWVkIHRvIGxvb2sgdGhhdCB1cC4KCWxv
Y2FsIHgxID0geDAgLSBpMSArIEc0OyAtLSBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4
LHkseix3KSBjb29yZHMKCWxvY2FsIHkxID0geTAgLSBqMSArIEc0OwoJbG9jYWwgejEgPSB6MCAt
IGsxICsgRzQ7Cglsb2NhbCB3MSA9IHcwIC0gbDEgKyBHNDsKCWxvY2FsIHgyID0geDAgLSBpMiAr
IDIuMCpHNDsgLS0gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseix3KSBjb29yZHMK
CWxvY2FsIHkyID0geTAgLSBqMiArIDIuMCpHNDsKCWxvY2FsIHoyID0gejAgLSBrMiArIDIuMCpH
NDsKCWxvY2FsIHcyID0gdzAgLSBsMiArIDIuMCpHNDsKCWxvY2FsIHgzID0geDAgLSBpMyArIDMu
MCpHNDsgLS0gT2Zmc2V0cyBmb3IgZm91cnRoIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzCgls
b2NhbCB5MyA9IHkwIC0gajMgKyAzLjAqRzQ7Cglsb2NhbCB6MyA9IHowIC0gazMgKyAzLjAqRzQ7
Cglsb2NhbCB3MyA9IHcwIC0gbDMgKyAzLjAqRzQ7Cglsb2NhbCB4NCA9IHgwIC0gMS4wICsgNC4w
Kkc0OyAtLSBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzCglsb2Nh
bCB5NCA9IHkwIC0gMS4wICsgNC4wKkc0OwoJbG9jYWwgejQgPSB6MCAtIDEuMCArIDQuMCpHNDsK
CWxvY2FsIHc0ID0gdzAgLSAxLjAgKyA0LjAqRzQ7CgoJLS0gV29yayBvdXQgdGhlIGhhc2hlZCBn
cmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmaXZlIHNpbXBsZXggY29ybmVycwoJbG9jYWwgaWkgPSBp
JjI1NQoJbG9jYWwgamogPSBqJjI1NQoJbG9jYWwga2sgPSBrJjI1NQoJbG9jYWwgbGwgPSBsJjI1
NQoJbG9jYWwgZ2kwID0gcGVybVtpaStwZXJtW2pqK3Blcm1ba2srcGVybVtsbF1dXV0gJSAzMjsK
CWxvY2FsIGdpMSA9IHBlcm1baWkraTErcGVybVtqaitqMStwZXJtW2trK2sxK3Blcm1bbGwrbDFd
XV1dICUgMzI7Cglsb2NhbCBnaTIgPSBwZXJtW2lpK2kyK3Blcm1bamorajIrcGVybVtraytrMitw
ZXJtW2xsK2wyXV1dXSAlIDMyOwoJbG9jYWwgZ2kzID0gcGVybVtpaStpMytwZXJtW2pqK2ozK3Bl
cm1ba2srazMrcGVybVtsbCtsM11dXV0gJSAzMjsKCWxvY2FsIGdpNCA9IHBlcm1baWkrMStwZXJt
W2pqKzErcGVybVtraysxK3Blcm1bbGwrMV1dXV0gJSAzMjsKCgktLSBDYWxjdWxhdGUgdGhlIGNv
bnRyaWJ1dGlvbiBmcm9tIHRoZSBmaXZlIGNvcm5lcnMKCWxvY2FsIHQwID0gMC41IC0geDAqeDAg
LSB5MCp5MCAtIHowKnowIC0gdzAqdzA7CglpZiAodDA8MCkgdGhlbgoJCW4wID0gMC4wOwoJZWxz
ZQoJCXQwID0gdDAqdDA7CgkJbjAgPSB0MCAqIHQwICogRG90NEQoR3JhZGllbnRzNERbZ2kwXSwg
eDAsIHkwLCB6MCwgdzApOwoJZW5kCgoJbG9jYWwgdDEgPSAwLjUgLSB4MSp4MSAtIHkxKnkxIC0g
ejEqejEgLSB3MSp3MTsKCWlmICh0MTwwKSB0aGVuCgkJbjEgPSAwLjA7CgllbHNlIAoJCXQxID0g
dDEqdDE7CgkJbjEgPSB0MSAqIHQxICogRG90NEQoR3JhZGllbnRzNERbZ2kxXSwgeDEsIHkxLCB6
MSwgdzEpOwoJZW5kCgoJbG9jYWwgdDIgPSAwLjUgLSB4Mip4MiAtIHkyKnkyIC0gejIqejIgLSB3
Mip3MjsKCWlmICh0MjwwKSB0aGVuCgkJbjIgPSAwLjA7CgllbHNlCgkJdDIgPSB0Mip0MjsKCQlu
MiA9IHQyICogdDIgKiBEb3Q0RChHcmFkaWVudHM0RFtnaTJdLCB4MiwgeTIsIHoyLCB3Mik7Cgll
bmQKCglsb2NhbCB0MyA9IDAuNSAtIHgzKngzIC0geTMqeTMgLSB6Myp6MyAtIHczKnczOwoJaWYg
KHQzPDApIHRoZW4KCQluMyA9IDAuMDsKCWVsc2UgCgkJdDMgPSB0Myp0MzsKCQluMyA9IHQzICog
dDMgKiBEb3Q0RChHcmFkaWVudHM0RFtnaTNdLCB4MywgeTMsIHozLCB3Myk7CgllbmQKCglsb2Nh
bCB0NCA9IDAuNSAtIHg0Kng0IC0geTQqeTQgLSB6NCp6NCAtIHc0Knc0OwoJaWYgKHQ0PDApIHRo
ZW4KCQluNCA9IDAuMDsKCWVsc2UKCQl0NCA9IHQ0KnQ0OwoJCW40ID0gdDQgKiB0NCAqIERvdDRE
KEdyYWRpZW50czREW2dpNF0sIHg0LCB5NCwgejQsIHc0KTsKCWVuZAoKCS0tIFN1bSB1cCBhbmQg
c2NhbGUgdGhlIHJlc3VsdCB0byBjb3ZlciB0aGUgcmFuZ2UgWy0xLDFdCgoJbG9jYWwgcmV0dmFs
ID0gMjcuMCAqIChuMCArIG4xICsgbjIgKyBuMyArIG40KQoKCWlmIHNpbXBsZXguaW50ZXJuYWxD
YWNoZSB0aGVuCgkJaWYgbm90IFByZXY0RFt4XSB0aGVuIFByZXY0RFt4XSA9IHt9IGVuZAoJCWlm
IG5vdCBQcmV2NERbeF1beV0gdGhlbiBQcmV2NERbeF1beV0gPSB7fSBlbmQKCQlpZiBub3QgUHJl
djREW3hdW3ldW3pdIHRoZW4gUHJldjREW3hdW3ldW3pdID0ge30gZW5kCgkJUHJldjREW3hdW3ld
W3pdW3ddID0gcmV0dmFsCgllbmQKCglyZXR1cm4gcmV0dmFsOwoKZW5kIAoKbG9jYWwgZSA9IDIu
NzE4MjgxODI4NDU5MDQ1MjM1MzYKCmxvY2FsIFByZXZCbHVyMkQgPSB7fQoKZnVuY3Rpb24gc2lt
cGxleC5HQmx1cjJEKHgseSxzdGREZXYpCglpZiBzaW1wbGV4LmludGVybmFsQ2FjaGUgYW5kIFBy
ZXZCbHVyMkRbeF0gYW5kIFByZXZCbHVyMkRbeF1beV0gYW5kIFByZXZCbHVyMkRbeF1beV1bc3Rk
RGV2XSB0aGVuIHJldHVybiBQcmV2Qmx1cjJEW3hdW3ldW3N0ZERldl0gZW5kCglsb2NhbCBwd3Ig
PSAoKHheMit5XjIpLygyKihzdGREZXZeMikpKSotMQoJbG9jYWwgcmV0ID0gKDEvKDIqbWF0aC5w
aSooc3RkRGV2XjIpKSkqKGVecHdyKQoKCWlmIHNpbXBsZXguaW50ZXJuYWxDYWNoZSB0aGVuCgkJ
aWYgbm90IFByZXZCbHVyMkRbeF0gdGhlbiBQcmV2Qmx1cjJEW3hdID0ge30gZW5kCgkJaWYgbm90
IFByZXZCbHVyMkRbeF1beV0gdGhlbiBQcmV2Qmx1cjJEW3hdW3ldID0ge30gZW5kCgkJUHJldkJs
dXIyRFt4XVt5XVtzdGREZXZdID0gcmV0CgllbmQKCXJldHVybiByZXQKZW5kIAoKbG9jYWwgUHJl
dkJsdXIxRCA9IHt9CgpmdW5jdGlvbiBzaW1wbGV4LkdCbHVyMUQoeCxzdGREZXYpCglpZiBzaW1w
bGV4LmludGVybmFsQ2FjaGUgYW5kIFByZXZCbHVyMURbeF0gYW5kIFByZXZCbHVyMURbeF1bc3Rk
RGV2XSB0aGVuIHJldHVybiBQcmV2Qmx1cjFEW3hdW3N0ZERldl0gZW5kCglsb2NhbCBwd3IgPSAo
eF4yLygyKnN0ZERldl4yKSkqLTEKCWxvY2FsIHJldCA9ICgxLyhtYXRoLnNxcnQoMiptYXRoLnBp
KSpzdGREZXYpKSooZV5wd3IpCgoJaWYgc2ltcGxleC5pbnRlcm5hbENhY2hlIHRoZW4KCQlpZiBu
b3QgUHJldkJsdXIxRFt4XSB0aGVuIFByZXZCbHVyMURbeF0gPSB7fSBlbmQKCQlQcmV2Qmx1cjFE
W3hdW3N0ZERldl0gPSByZXQKCWVuZAoJcmV0dXJuIHJldAplbmQKCmZ1bmN0aW9uIHNpbXBsZXgu
RnJhY3RhbFN1bShmdW5jLCBpdGVyLCAuLi4pCiAgICBsb2NhbCByZXQgPSBmdW5jKC4uLikKICAg
IGZvciBpPTEsaXRlciBkbwogICAgICAgIGxvY2FsIHBvd2VyID0gMl5pdGVyCiAgICAgICAgbG9j
YWwgcyA9IHBvd2VyL2kKCiAgICAgICAgbG9jYWwgc2NhbGVkID0ge30KICAgICAgICBmb3IgZWxl
bSBpbiBpcGFpcnMoey4uLn0pIGRvCiAgICAgICAgICAgIHRhYmxlLmluc2VydChzY2FsZWQsIGVs
ZW0qcykKICAgICAgICBlbmQKICAgICAgICByZXQgPSByZXQgKyAoaS9wb3dlcikqKGZ1bmModW5w
YWNrKHNjYWxlZCkpKQogICAgZW5kCiAgICByZXR1cm4gcmV0CmVuZAoKZnVuY3Rpb24gc2ltcGxl
eC5GcmFjdGFsU3VtQWJzKGZ1bmMsIGl0ZXIsIC4uLikKICAgIGxvY2FsIHJldCA9IG1hdGguYWJz
KGZ1bmMoLi4uKSkKICAgIGZvciBpPTEsaXRlciBkbwogICAgICAgIGxvY2FsIHBvd2VyID0gMl5p
dGVyCiAgICAgICAgbG9jYWwgcyA9IHBvd2VyL2kKCiAgICAgICAgbG9jYWwgc2NhbGVkID0ge30K
ICAgICAgICBmb3IgZWxlbSBpbiBpcGFpcnMoey4uLn0pIGRvCiAgICAgICAgICAgIHRhYmxlLmlu
c2VydChzY2FsZWQsIGVsZW0qcykKICAgICAgICBlbmQKICAgICAgICByZXQgPSByZXQgKyAoaS9w
b3dlcikqKG1hdGguYWJzKGZ1bmModW5wYWNrKHNjYWxlZCkpKSkKICAgIGVuZAogICAgcmV0dXJu
IHJldAplbmQKCmZ1bmN0aW9uIHNpbXBsZXguVHVyYnVsZW5jZShmdW5jLCBkaXJlY3Rpb24sIGl0
ZXIsIC4uLikKICAgIGxvY2FsIHJldCA9IG1hdGguYWJzKGZ1bmMoLi4uKSkKICAgIGZvciBpPTEs
aXRlciBkbwogICAgICAgIGxvY2FsIHBvd2VyID0gMl5pdGVyCiAgICAgICAgbG9jYWwgcyA9IHBv
d2VyL2kKCiAgICAgICAgbG9jYWwgc2NhbGVkID0ge30KICAgICAgICBmb3IgZWxlbSBpbiBpcGFp
cnMoey4uLn0pIGRvCiAgICAgICAgICAgIHRhYmxlLmluc2VydChzY2FsZWQsIGVsZW0qcykKICAg
ICAgICBlbmQKICAgICAgICByZXQgPSByZXQgKyAoaS9wb3dlcikqKG1hdGguYWJzKGZ1bmModW5w
YWNrKHNjYWxlZCkpKSkKICAgIGVuZAogICAgbG9jYWwgYXJncyA9IHsuLi59CiAgICBsb2NhbCBk
aXJfY29tcG9uZW50ID0gYXJnc1tkaXJlY3Rpb24rMV0KICAgIHJldHVybiBtYXRoLnNpbihkaXJf
Y29tcG9uZW50K3JldCkKZW5k
:: noise.lua
b64$LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNS0wNC0wOSAxOTozNDoyMyIsbW9k
aWZpZWQ9IjIwMjUtMDUtMDEgMDk6Mzg6NDYiLHJldmlzaW9uPTExMTZdXQotLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS1TaW1wbGV4IE5vaXNlCi0tIE9y
aWdpbmFsIEphdmEgU291cmNlOiBodHRwOi8vc3RhZmZ3d3cuaXRuLmxpdS5zZS9_c3RlZ3Uvc2lt
cGxleG5vaXNlL3NpbXBsZXhub2lzZS5wZGYKLS0gKG1vc3QpIE9yaWdpbmFsIGNvbW1lbnRzIGlu
Y2x1ZGVkCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgps
b2NhbCBtYXRoID0gbWF0aApsb2NhbCB0YWJsZSA9IHRhYmxlCmxvY2FsIHRvbnVtYmVyID0gdG9u
dW1iZXIKbG9jYWwgaXBhaXJzID0gaXBhaXJzCmxvY2FsIGVycm9yID0gZXJyb3IKCnNpbXBsZXgg
PSB7fQoKc2ltcGxleC5ESVJfWCA9IDAKc2ltcGxleC5ESVJfWSA9IDEKc2ltcGxleC5ESVJfWiA9
IDIKc2ltcGxleC5ESVJfVyA9IDMKc2ltcGxleC5pbnRlcm5hbENhY2hlID0gZmFsc2UKCmxvY2Fs
IEdyYWRpZW50czNEID0ge3sxLDEsMH0sey0xLDEsMH0sezEsLTEsMH0sey0xLC0xLDB9LAp7MSww
LDF9LHstMSwwLDF9LHsxLDAsLTF9LHstMSwwLC0xfSwKezAsMSwxfSx7MCwtMSwxfSx7MCwxLC0x
fSx7MCwtMSwtMX19Owpsb2NhbCBHcmFkaWVudHM0RCA9IHt7MCwxLDEsMX0sIHswLDEsMSwtMX0s
IHswLDEsLTEsMX0sIHswLDEsLTEsLTF9LAp7MCwtMSwxLDF9LCB7MCwtMSwxLC0xfSwgezAsLTEs
LTEsMX0sIHswLC0xLC0xLC0xfSwKezEsMCwxLDF9LCB7MSwwLDEsLTF9LCB7MSwwLC0xLDF9LCB7
MSwwLC0xLC0xfSwKey0xLDAsMSwxfSwgey0xLDAsMSwtMX0sIHstMSwwLC0xLDF9LCB7LTEsMCwt
MSwtMX0sCnsxLDEsMCwxfSwgezEsMSwwLC0xfSwgezEsLTEsMCwxfSwgezEsLTEsMCwtMX0sCnst
MSwxLDAsMX0sIHstMSwxLDAsLTF9LCB7LTEsLTEsMCwxfSwgey0xLC0xLDAsLTF9LAp7MSwxLDEs
MH0sIHsxLDEsLTEsMH0sIHsxLC0xLDEsMH0sIHsxLC0xLC0xLDB9LAp7LTEsMSwxLDB9LCB7LTEs
MSwtMSwwfSwgey0xLC0xLDEsMH0sIHstMSwtMSwtMSwwfX07CmxvY2FsIHAgPSB7MTUxLDE2MCwx
MzcsOTEsOTAsMTUsCjEzMSwxMywyMDEsOTUsOTYsNTMsMTk0LDIzMyw3LDIyNSwxNDAsMzYsMTAz
LDMwLDY5LDE0Miw4LDk5LDM3LDI0MCwyMSwxMCwyMywKMTkwLCA2LDE0OCwyNDcsMTIwLDIzNCw3
NSwwLDI2LDE5Nyw2Miw5NCwyNTIsMjE5LDIwMywxMTcsMzUsMTEsMzIsNTcsMTc3LDMzLAo4OCwy
MzcsMTQ5LDU2LDg3LDE3NCwyMCwxMjUsMTM2LDE3MSwxNjgsIDY4LDE3NSw3NCwxNjUsNzEsMTM0
LDEzOSw0OCwyNywxNjYsCjc3LDE0NiwxNTgsMjMxLDgzLDExMSwyMjksMTIyLDYwLDIxMSwxMzMs
MjMwLDIyMCwxMDUsOTIsNDEsNTUsNDYsMjQ1LDQwLDI0NCwKMTAyLDE0Myw1NCwgNjUsMjUsNjMs
MTYxLCAxLDIxNiw4MCw3MywyMDksNzYsMTMyLDE4NywyMDgsIDg5LDE4LDE2OSwyMDAsMTk2LAox
MzUsMTMwLDExNiwxODgsMTU5LDg2LDE2NCwxMDAsMTA5LDE5OCwxNzMsMTg2LCAzLDY0LDUyLDIx
NywyMjYsMjUwLDEyNCwxMjMsCjUsMjAyLDM4LDE0NywxMTgsMTI2LDI1NSw4Miw4NSwyMTIsMjA3
LDIwNiw1OSwyMjcsNDcsMTYsNTgsMTcsMTgyLDE4OSwyOCw0MiwKMjIzLDE4MywxNzAsMjEzLDEx
OSwyNDgsMTUyLCAyLDQ0LDE1NCwxNjMsIDcwLDIyMSwxNTMsMTAxLDE1NSwxNjcsIDQzLDE3Miw5
LAoxMjksMjIsMzksMjUzLCAxOSw5OCwxMDgsMTEwLDc5LDExMywyMjQsMjMyLDE3OCwxODUsIDEx
MiwxMDQsMjE4LDI0Niw5NywyMjgsCjI1MSwzNCwyNDIsMTkzLDIzOCwyMTAsMTQ0LDEyLDE5MSwx
NzksMTYyLDI0MSwgODEsNTEsMTQ1LDIzNSwyNDksMTQsMjM5LDEwNywKNDksMTkyLDIxNCwgMzEs
MTgxLDE5OSwxMDYsMTU3LDE4NCwgODQsMjA0LDE3NiwxMTUsMTIxLDUwLDQ1LDEyNywgNCwxNTAs
MjU0LAoxMzgsMjM2LDIwNSw5MywyMjIsMTE0LDY3LDI5LDI0LDcyLDI0MywxNDEsMTI4LDE5NSw3
OCw2NiwyMTUsNjEsMTU2LDE4MH07CgotLSBUbyByZW1vdmUgdGhlIG5lZWQgZm9yIGluZGV4IHdy
YXBwaW5nLCBkb3VibGUgdGhlIHBlcm11dGF0aW9uIHRhYmxlIGxlbmd0aAoKZm9yIGk9MSwjcCBk
bwoJcFtpLTFdID0gcFtpXQoJcFtpXSA9IG5pbAplbmQKCmZvciBpPTEsI0dyYWRpZW50czNEIGRv
CglHcmFkaWVudHMzRFtpLTFdID0gR3JhZGllbnRzM0RbaV0KCUdyYWRpZW50czNEW2ldID0gbmls
CmVuZAoKZm9yIGk9MSwjR3JhZGllbnRzNEQgZG8KCUdyYWRpZW50czREW2ktMV0gPSBHcmFkaWVu
dHM0RFtpXQoJR3JhZGllbnRzNERbaV0gPSBuaWwKZW5kCgpsb2NhbCBwZXJtID0ge30KCmZvciBp
PTAsMjU1IGRvCglwZXJtW2ldID0gcFtpXQoJcGVybVtpKzI1Nl0gPSBwW2ldCmVuZAoKLS0gQSBs
b29rdXAgdGFibGUgdG8gdHJhdmVyc2UgdGhlIHNpbSBhcm91bmQgYSBnaXZlbiBwb2ludCBpbiA0
RC4KLS0gRGV0YWlscyBjYW4gYmUgZm91bmQgd2hlcmUgdGhpcyB0YWJsZSBpcyB1c2VkLCBpbiB0
aGUgNEQgbm9pc2UgbWV0aG9kLgoKbG9jYWwgc2ltID0gewp7MCwxLDIsM30sezAsMSwzLDJ9LHsw
LDAsMCwwfSx7MCwyLDMsMX0sezAsMCwwLDB9LHswLDAsMCwwfSx7MCwwLDAsMH0sezEsMiwzLDB9
LAp7MCwyLDEsM30sezAsMCwwLDB9LHswLDMsMSwyfSx7MCwzLDIsMX0sezAsMCwwLDB9LHswLDAs
MCwwfSx7MCwwLDAsMH0sezEsMywyLDB9LAp7MCwwLDAsMH0sezAsMCwwLDB9LHswLDAsMCwwfSx7
MCwwLDAsMH0sezAsMCwwLDB9LHswLDAsMCwwfSx7MCwwLDAsMH0sezAsMCwwLDB9LAp7MSwyLDAs
M30sezAsMCwwLDB9LHsxLDMsMCwyfSx7MCwwLDAsMH0sezAsMCwwLDB9LHswLDAsMCwwfSx7Miwz
LDAsMX0sezIsMywxLDB9LAp7MSwwLDIsM30sezEsMCwzLDJ9LHswLDAsMCwwfSx7MCwwLDAsMH0s
ezAsMCwwLDB9LHsyLDAsMywxfSx7MCwwLDAsMH0sezIsMSwzLDB9LAp7MCwwLDAsMH0sezAsMCww
LDB9LHswLDAsMCwwfSx7MCwwLDAsMH0sezAsMCwwLDB9LHswLDAsMCwwfSx7MCwwLDAsMH0sezAs
MCwwLDB9LAp7MiwwLDEsM30sezAsMCwwLDB9LHswLDAsMCwwfSx7MCwwLDAsMH0sezMsMCwxLDJ9
LHszLDAsMiwxfSx7MCwwLDAsMH0sezMsMSwyLDB9LAp7MiwxLDAsM30sezAsMCwwLDB9LHswLDAs
MCwwfSx7MCwwLDAsMH0sezMsMSwwLDJ9LHswLDAsMCwwfSx7MywyLDAsMX0sezMsMiwxLDB9fTsK
CmxvY2FsIGZ1bmN0aW9uIERvdDJEKHRibCwgeCwgeSkKCXJldHVybiB0YmxbMV0qeCArIHRibFsy
XSp5OyAKZW5kCgpsb2NhbCBmdW5jdGlvbiBEb3QzRCh0YmwsIHgsIHksIHopCglyZXR1cm4gdGJs
WzFdKnggKyB0YmxbMl0qeSArIHRibFszXSp6CmVuZAoKbG9jYWwgZnVuY3Rpb24gRG90NEQoIHRi
bCwgeCx5LHosdykgCglyZXR1cm4gdGJsWzFdKnggKyB0YmxbMl0qeSArIHRibFszXSp6ICsgdGJs
WzNdKnc7CmVuZAoKbG9jYWwgUHJldjJEID0ge30KCi0tIDJEIHNpbXBsZXggbm9pc2UKCmZ1bmN0
aW9uIHNpbXBsZXguTm9pc2UyRCh4aW4sIHlpbikKCWlmIHNpbXBsZXguaW50ZXJuYWxDYWNoZSBh
bmQgUHJldjJEW3hpbl0gYW5kIFByZXYyRFt4aW5dW3lpbl0gdGhlbiByZXR1cm4gUHJldjJEW3hp
bl1beWluXSBlbmQgCgoJbG9jYWwgbjAsIG4xLCBuMjsgLS0gTm9pc2UgY29udHJpYnV0aW9ucyBm
cm9tIHRoZSB0aHJlZSBjb3JuZXJzCgktLSBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1p
bmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluCglsb2NhbCBGMiA9IDAuNSoobWF0aC5zcXJ0
KDMuMCktMS4wKTsKCWxvY2FsIHMgPSAoeGluK3lpbikqRjI7IC0tIEhhaXJ5IGZhY3RvciBmb3Ig
MkQKCWxvY2FsIGkgPSBtYXRoLmZsb29yKHhpbitzKTsKCWxvY2FsIGogPSBtYXRoLmZsb29yKHlp
bitzKTsKCWxvY2FsIEcyID0gKDMuMC1tYXRoLnNxcnQoMy4wKSkvNi4wOwoKCWxvY2FsIHQgPSAo
aStqKSpHMjsKCWxvY2FsIFgwID0gaS10OyAtLSBVbnNrZXcgdGhlIGNlbGwgb3JpZ2luIGJhY2sg
dG8gKHgseSkgc3BhY2UKCWxvY2FsIFkwID0gai10OwoJbG9jYWwgeDAgPSB4aW4tWDA7IC0tIFRo
ZSB4LHkgZGlzdGFuY2VzIGZyb20gdGhlIGNlbGwgb3JpZ2luCglsb2NhbCB5MCA9IHlpbi1ZMDsK
CgktLSBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFs
IHRyaWFuZ2xlLgoJLS0gRGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggd2UgYXJlIGluLgoJbG9jYWwg
aTEsIGoxOyAtLSBPZmZzZXRzIGZvciBzZWNvbmQgKG1pZGRsZSkgY29ybmVyIG9mIHNpbXBsZXgg
aW4gKGksaikgY29vcmRzCglpZih4MD55MCkgdGhlbiAKCQlpMT0xIAoJCWoxPTAgIC0tIGxvd2Vy
IHRyaWFuZ2xlLCBYWSBvcmRlcjogKDAsMCktPigxLDApLT4oMSwxKQoJZWxzZQoJCWkxPTAKCQlq
MT0xIC0tIHVwcGVyIHRyaWFuZ2xlLCBZWCBvcmRlcjogKDAsMCktPigwLDEpLT4oMSwxKQoJZW5k
CgoJLS0gQSBzdGVwIG9mICgxLDApIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jKSBp
biAoeCx5KSwgYW5kCgktLSBhIHN0ZXAgb2YgKDAsMSkgaW4gKGksaikgbWVhbnMgYSBzdGVwIG9m
ICgtYywxLWMpIGluICh4LHkpLCB3aGVyZQoJLS0gYyA9ICgzLXNxcnQoMykpLzYKCglsb2NhbCB4
MSA9IHgwIC0gaTEgKyBHMjsgLS0gT2Zmc2V0cyBmb3IgbWlkZGxlIGNvcm5lciBpbiAoeCx5KSB1
bnNrZXdlZCBjb29yZHMKCWxvY2FsIHkxID0geTAgLSBqMSArIEcyOwoJbG9jYWwgeDIgPSB4MCAt
IDEuMCArIDIuMCAqIEcyOyAtLSBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5KSB1bnNr
ZXdlZCBjb29yZHMKCWxvY2FsIHkyID0geTAgLSAxLjAgKyAyLjAgKiBHMjsKCgktLSBXb3JrIG91
dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIHRocmVlIHNpbXBsZXggY29ybmVy
cwoJbG9jYWwgaWkgPSBpJjI1NQoJbG9jYWwgamogPSBqJjI1NQoJbG9jYWwgZ2kwID0gcGVybVtp
aStwZXJtW2pqXV0gJSAxMjsKCWxvY2FsIGdpMSA9IHBlcm1baWkraTErcGVybVtqaitqMV1dICUg
MTI7Cglsb2NhbCBnaTIgPSBwZXJtW2lpKzErcGVybVtqaisxXV0gJSAxMjsKCgktLSBDYWxjdWxh
dGUgdGhlIGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSB0aHJlZSBjb3JuZXJzCglsb2NhbCB0MCA9IDAu
NSAtIHgwKngwLXkwKnkwOwoJaWYgdDA8MCB0aGVuIAoJCW4wID0gMC4wOwoJZWxzZQoJCXQwID0g
dDAgKiB0MAoJCW4wID0gdDAgKiB0MCAqIERvdDJEKEdyYWRpZW50czNEW2dpMF0sIHgwLCB5MCk7
IC0tICh4LHkpIG9mIEdyYWRpZW50czNEIHVzZWQgZm9yIDJEIGdyYWRpZW50CgllbmQKCglsb2Nh
bCB0MSA9IDAuNSAtIHgxKngxLXkxKnkxOwoJaWYgKHQxPDApIHRoZW4KCQluMSA9IDAuMDsKCWVs
c2UKCQl0MSA9IHQxKnQxCgkJbjEgPSB0MSAqIHQxICogRG90MkQoR3JhZGllbnRzM0RbZ2kxXSwg
eDEsIHkxKTsKCWVuZAoKCWxvY2FsIHQyID0gMC41IC0geDIqeDIteTIqeTI7CglpZiAodDI8MCkg
dGhlbgoJCW4yID0gMC4wOwoJZWxzZQoJCXQyID0gdDIqdDIKCQluMiA9IHQyICogdDIgKiBEb3Qy
RChHcmFkaWVudHMzRFtnaTJdLCB4MiwgeTIpOwoJZW5kCgoJLS0gQWRkIGNvbnRyaWJ1dGlvbnMg
ZnJvbSBlYWNoIGNvcm5lciB0byBnZXQgdGhlIGZpbmFsIG5vaXNlIHZhbHVlLgoJLS0gVGhlIHJl
c3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgbG9jYWxlcnZhbCBbLTEsMV0u
CgoJbG9jYWwgcmV0dmFsID0gNzAuMCAqIChuMCArIG4xICsgbjIpCgoJaWYgc2ltcGxleC5pbnRl
cm5hbENhY2hlIHRoZW4KCQlpZiBub3QgUHJldjJEW3hpbl0gdGhlbiBQcmV2MkRbeGluXSA9IHt9
IGVuZAoJCVByZXYyRFt4aW5dW3lpbl0gPSByZXR2YWwKCWVuZAoKCXJldHVybiByZXR2YWw7CmVu
ZAoKbG9jYWwgUHJldjNEID0ge30KCi0tIDNEIHNpbXBsZXggbm9pc2UKZnVuY3Rpb24gc2ltcGxl
eC5Ob2lzZTNEKHhpbiwgeWluLCB6aW4pCgoJbG9jYWwgbjAsIG4xLCBuMiwgbjM7IC0tIE5vaXNl
IGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZm91ciBjb3JuZXJzCgoJLS0gU2tldyB0aGUgaW5wdXQg
c3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIHNpbXBsZXggY2VsbCB3ZSdyZSBpbgoJbG9jYWwgRjMg
PSAxLjAvMy4wOwoJbG9jYWwgcyA9ICh4aW4reWluK3ppbikqRjM7IC0tIFZlcnkgbmljZSBhbmQg
c2ltcGxlIHNrZXcgZmFjdG9yIGZvciAzRAoJbG9jYWwgaSA9IG1hdGguZmxvb3IoeGluK3MpOwoJ
bG9jYWwgaiA9IG1hdGguZmxvb3IoeWluK3MpOwoJbG9jYWwgayA9IG1hdGguZmxvb3IoemluK3Mp
OwoKCWxvY2FsIEczID0gMS4wLzYuMDsgLS0gVmVyeSBuaWNlIGFuZCBzaW1wbGUgdW5za2V3IGZh
Y3RvciwgdG9vCglsb2NhbCB0ID0gKGkraitrKSpHMzsKCglsb2NhbCBYMCA9IGktdDsgLS0gVW5z
a2V3IHRoZSBjZWxsIG9yaWdpbiBiYWNrIHRvICh4LHkseikgc3BhY2UKCWxvY2FsIFkwID0gai10
OwoJbG9jYWwgWjAgPSBrLXQ7CgoJbG9jYWwgeDAgPSB4aW4tWDA7IC0tIFRoZSB4LHkseiBkaXN0
YW5jZXMgZnJvbSB0aGUgY2VsbCBvcmlnaW4KCWxvY2FsIHkwID0geWluLVkwOwoJbG9jYWwgejAg
PSB6aW4tWjA7CgoJLS0gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNs
aWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi4KCS0tIERldGVybWluZSB3aGljaCBzaW1wbGV4
IHdlIGFyZSBpbi4KCWxvY2FsIGkxLCBqMSwgazE7IC0tIE9mZnNldHMgZm9yIHNlY29uZCBjb3Ju
ZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3JkcwoJbG9jYWwgaTIsIGoyLCBrMjsgLS0gT2Zm
c2V0cyBmb3IgdGhpcmQgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaixrKSBjb29yZHMKCglpZiAo
eDA_PXkwKSB0aGVuCgkJaWYgKHkwPj16MCkgdGhlbgoJCQlpMT0xOyBqMT0wOyBrMT0wOyBpMj0x
OyBqMj0xOyBrMj0wOyAtLSBYIFkgWiBvcmRlcgoJCWVsc2VpZiAoeDA_PXowKSB0aGVuCgkJCWkx
PTE7IGoxPTA7IGsxPTA7IGkyPTE7IGoyPTA7IGsyPTE7IC0tIFggWiBZIG9yZGVyCgkJZWxzZSAK
CQkJaTE9MDsgajE9MDsgazE9MTsgaTI9MTsgajI9MDsgazI9MTsgIC0tIFogWCBZIG9yZGVyCgkJ
ZW5kCgllbHNlIC0tIHgwPHkwCgkJaWYgKHkwPHowKSB0aGVuIAoJCQlpMT0wOyBqMT0wOyBrMT0x
OyBpMj0wOyBqMj0xOyBrMj0xOyAtLSBaIFkgWCBvcmRlcgoJCWVsc2VpZiAoeDA8ejApIHRoZW4g
CgkJCWkxPTA7IGoxPTE7IGsxPTA7IGkyPTA7IGoyPTE7IGsyPTE7IC0tIFkgWiBYIG9yZGVyCgkJ
ZWxzZSAKCQkJaTE9MDsgajE9MTsgazE9MDsgaTI9MTsgajI9MTsgazI9MDsgLS0gWSBYIFogb3Jk
ZXIKCQllbmQKCWVuZAoKCS0tIEEgc3RlcCBvZiAoMSwwLDApIGluIChpLGosaykgbWVhbnMgYSBz
dGVwIG9mICgxLWMsLWMsLWMpIGluICh4LHkseiksCgktLSBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAo
aSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmQKCS0tIGEg
c3RlcCBvZiAoMCwwLDEpIGluIChpLGosaykgbWVhbnMgYSBzdGVwIG9mICgtYywtYywxLWMpIGlu
ICh4LHkseiksIHdoZXJlCgktLSBjID0gMS82LgoKCWxvY2FsIHgxID0geDAgLSBpMSArIEczOyAt
LSBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGluICh4LHkseikgY29vcmRzCglsb2NhbCB5MSA9
IHkwIC0gajEgKyBHMzsKCWxvY2FsIHoxID0gejAgLSBrMSArIEczOwoKCWxvY2FsIHgyID0geDAg
LSBpMiArIDIuMCpHMzsgLS0gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseikgY29v
cmRzCglsb2NhbCB5MiA9IHkwIC0gajIgKyAyLjAqRzM7Cglsb2NhbCB6MiA9IHowIC0gazIgKyAy
LjAqRzM7CgoJbG9jYWwgeDMgPSB4MCAtIDEuMCArIDMuMCpHMzsgLS0gT2Zmc2V0cyBmb3IgbGFz
dCBjb3JuZXIgaW4gKHgseSx6KSBjb29yZHMKCWxvY2FsIHkzID0geTAgLSAxLjAgKyAzLjAqRzM7
Cglsb2NhbCB6MyA9IHowIC0gMS4wICsgMy4wKkczOwoKCS0tIFdvcmsgb3V0IHRoZSBoYXNoZWQg
Z3JhZGllbnQgaW5kaWNlcyBvZiB0aGUgZm91ciBzaW1wbGV4IGNvcm5lcnMKCWxvY2FsIGlpID0g
aSYyNTUKCWxvY2FsIGpqID0gaiYyNTUKCWxvY2FsIGtrID0gayYyNTUKCglsb2NhbCBnaTAgPSBw
ZXJtW2lpK3Blcm1bamorcGVybVtra11dXSAlIDEyOwoJbG9jYWwgZ2kxID0gcGVybVtpaStpMStw
ZXJtW2pqK2oxK3Blcm1ba2srazFdXV0gJSAxMjsKCWxvY2FsIGdpMiA9IHBlcm1baWkraTIrcGVy
bVtqaitqMitwZXJtW2trK2syXV1dICUgMTI7Cglsb2NhbCBnaTMgPSBwZXJtW2lpKzErcGVybVtq
aisxK3Blcm1ba2srMV1dXSAlIDEyOwoKCS0tIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZy
b20gdGhlIGZvdXIgY29ybmVycwoJbG9jYWwgdDAgPSAwLjUgLSB4MCp4MCAtIHkwKnkwIC0gejAq
ejA7CgoJaWYgKHQwPDApIHRoZW4KCQluMCA9IDAuMDsKCWVsc2UgCgkJdDAgPSB0MCp0MDsKCQlu
MCA9IHQwICogdDAgKiBEb3QzRChHcmFkaWVudHMzRFtnaTBdLCB4MCwgeTAsIHowKTsKCWVuZAoK
CWxvY2FsIHQxID0gMC41IC0geDEqeDEgLSB5MSp5MSAtIHoxKnoxOwoKCWlmICh0MTwwKSB0aGVu
IAoJCW4xID0gMC4wOwoJZWxzZQoJCXQxID0gdDEqdDE7CgkJbjEgPSB0MSAqIHQxICogRG90M0Qo
R3JhZGllbnRzM0RbZ2kxXSwgeDEsIHkxLCB6MSk7CgllbmQKCglsb2NhbCB0MiA9IDAuNSAtIHgy
KngyIC0geTIqeTIgLSB6Mip6MjsKCglpZiAodDI8MCkgdGhlbiAKCQluMiA9IDAuMDsKCWVsc2UK
CQl0MiA9IHQyKnQyOwoJCW4yID0gdDIgKiB0MiAqIERvdDNEKEdyYWRpZW50czNEW2dpMl0sIHgy
LCB5MiwgejIpOwoJZW5kCgoJbG9jYWwgdDMgPSAwLjUgLSB4Myp4MyAtIHkzKnkzIC0gejMqejM7
CgoJaWYgKHQzPDApIHRoZW4gCgkJbjMgPSAwLjA7CgllbHNlCgkJdDMgPSB0Myp0MzsKCQluMyA9
IHQzICogdDMgKiBEb3QzRChHcmFkaWVudHMzRFtnaTNdLCB4MywgeTMsIHozKTsKCWVuZAoKCS0t
IEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lz
ZSB2YWx1ZS4KCS0tIFRoZSByZXN1bHQgaXMgc2NhbGVkIHRvIHN0YXkganVzdCBpbnNpZGUgWy0x
LDFdCglsb2NhbCByZXR2YWwgPSA0NiAqIChuMCArIG4xICsgbjIgKyBuMykKCglyZXR1cm4gcmV0
dmFsOwplbmQKCmxvY2FsIFByZXY0RCA9IHt9CgotLSA0RCBzaW1wbGV4IG5vaXNlCmZ1bmN0aW9u
IHNpbXBsZXguTm9pc2U0RCh4LHkseix3KQoKCWlmIHNpbXBsZXguaW50ZXJuYWxDYWNoZSBhbmQg
UHJldjREW3hdIGFuZCBQcmV2NERbeF1beV0gYW5kIFByZXY0RFt4XVt5XVt6XSBhbmQgUHJldjRE
W3hdW3ldW3pdW3ddIHRoZW4gcmV0dXJuIFByZXY0RFt4XVt5XVt6XVt3XSBlbmQKCgktLSBUaGUg
c2tld2luZyBhbmQgdW5za2V3aW5nIGZhY3RvcnMgYXJlIGhhaXJ5IGFnYWluIGZvciB0aGUgNEQg
Y2FzZQoJbG9jYWwgRjQgPSAobWF0aC5zcXJ0KDUuMCktMS4wKS80LjA7Cglsb2NhbCBHNCA9ICg1
LjAtbWF0aC5zcXJ0KDUuMCkpLzIwLjA7Cglsb2NhbCBuMCwgbjEsIG4yLCBuMywgbjQ7IC0tIE5v
aXNlIGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzCgktLSBTa2V3IHRoZSAoeCx5
LHosdykgc3BhY2UgdG8gZGV0ZXJtaW5lIHdoaWNoIGNlbGwgb2YgMjQgc2ltcGxpY2VzIHdlJ3Jl
IGluCglsb2NhbCBzID0gKHggKyB5ICsgeiArIHcpICogRjQ7IC0tIEZhY3RvciBmb3IgNEQgc2tl
d2luZwoJbG9jYWwgaSA9IG1hdGguZmxvb3IoeCArIHMpOwoJbG9jYWwgaiA9IG1hdGguZmxvb3Io
eSArIHMpOwoJbG9jYWwgayA9IG1hdGguZmxvb3IoeiArIHMpOwoJbG9jYWwgbCA9IG1hdGguZmxv
b3IodyArIHMpOwoJbG9jYWwgdCA9IChpICsgaiArIGsgKyBsKSAqIEc0OyAtLSBGYWN0b3IgZm9y
IDREIHVuc2tld2luZwoJbG9jYWwgWDAgPSBpIC0gdDsgLS0gVW5za2V3IHRoZSBjZWxsIG9yaWdp
biBiYWNrIHRvICh4LHkseix3KSBzcGFjZQoJbG9jYWwgWTAgPSBqIC0gdDsKCWxvY2FsIFowID0g
ayAtIHQ7Cglsb2NhbCBXMCA9IGwgLSB0OwoJbG9jYWwgeDAgPSB4IC0gWDA7IC0tIFRoZSB4LHks
eix3IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpbgoJbG9jYWwgeTAgPSB5IC0gWTA7Cgls
b2NhbCB6MCA9IHogLSBaMDsKCWxvY2FsIHcwID0gdyAtIFcwOwoJLS0gRm9yIHRoZSA0RCBjYXNl
LCB0aGUgc2ltcGxleCBpcyBhIDREIHNoYXBlIEkgd29uJ3QgZXZlbiB0cnkgdG8gZGVzY3JpYmUu
CgktLSBUbyBmaW5kIG91dCB3aGljaCBvZiB0aGUgMjQgcG9zc2libGUgc2ltcGxpY2VzIHdlJ3Jl
IGluLCB3ZSBuZWVkIHRvCgktLSBkZXRlcm1pbmUgdGhlIG1hZ25pdHVkZSBvcmRlcmluZyBvZiB4
MCwgeTAsIHowIGFuZCB3MC4KCS0tIFRoZSBtZXRob2QgYmVsb3cgaXMgYSBnb29kIHdheSBvZiBm
aW5kaW5nIHRoZSBvcmRlcmluZyBvZiB4LHkseix3IGFuZAoJLS0gdGhlbiBmaW5kIHRoZSBjb3Jy
ZWN0IHRyYXZlcnNhbCBvcmRlciBmb3IgdGhlIHNpbXBsZXggd2Xvv71yZSBpbi4KCS0tIEZpcnN0
LCBzaXggcGFpci13aXNlIGNvbXBhcmlzb25zIGFyZSBwZXJmb3JtZWQgYmV0d2VlbiBlYWNoIHBv
c3NpYmxlIHBhaXIKCS0tIG9mIHRoZSBmb3VyIGNvb3JkaW5hdGVzLCBhbmQgdGhlIHJlc3VsdHMg
YXJlIHVzZWQgdG8gYWRkIHVwIGJpbmFyeSBiaXRzCgktLSBmb3IgYW4gbG9jYWxlZ2VyIGluZGV4
LgoJbG9jYWwgYzEgPSAoeDAgPiB5MCkgYW5kIDMyIG9yIDE7Cglsb2NhbCBjMiA9ICh4MCA_IHow
KSBhbmQgMTYgb3IgMTsKCWxvY2FsIGMzID0gKHkwID4gejApIGFuZCA4IG9yIDE7Cglsb2NhbCBj
NCA9ICh4MCA_IHcwKSBhbmQgNCBvciAxOwoJbG9jYWwgYzUgPSAoeTAgPiB3MCkgYW5kIDIgb3Ig
MTsKCWxvY2FsIGM2ID0gKHowID4gdzApIGFuZCAxIG9yIDE7Cglsb2NhbCBjID0gYzEgKyBjMiAr
IGMzICsgYzQgKyBjNSArIGM2OwoJbG9jYWwgaTEsIGoxLCBrMSwgbDE7IC0tIFRoZSBsb2NhbGVn
ZXIgb2Zmc2V0cyBmb3IgdGhlIHNlY29uZCBzaW1wbGV4IGNvcm5lcgoJbG9jYWwgaTIsIGoyLCBr
MiwgbDI7IC0tIFRoZSBsb2NhbGVnZXIgb2Zmc2V0cyBmb3IgdGhlIHRoaXJkIHNpbXBsZXggY29y
bmVyCglsb2NhbCBpMywgajMsIGszLCBsMzsgLS0gVGhlIGxvY2FsZWdlciBvZmZzZXRzIGZvciB0
aGUgZm91cnRoIHNpbXBsZXggY29ybmVyCgoJLS0gc2ltW2NdIGlzIGEgNC12ZWN0b3Igd2l0aCB0
aGUgbnVtYmVycyAwLCAxLCAyIGFuZCAzIGluIHNvbWUgb3JkZXIuCgktLSBNYW55IHZhbHVlcyBv
ZiBjIHdpbGwgbmV2ZXIgb2NjdXIsIHNpbmNlIGUuZy4geD55Pno_dyBtYWtlcyB4PHosIHk8dyBh
bmQgeDx3CgktLSBpbXBvc3NpYmxlLiBPbmx5IHRoZSAyNCBpbmRpY2VzIHdoaWNoIGhhdmUgbm9u
LXplcm8gZW50cmllcyBtYWtlIGFueSBzZW5zZS4KCS0tIFdlIHVzZSBhIHRocmVzaG9sZGluZyB0
byBzZXQgdGhlIGNvb3JkaW5hdGVzIGluIHR1cm4gZnJvbSB0aGUgbGFyZ2VzdCBtYWduaXR1ZGUu
CgktLSBUaGUgbnVtYmVyIDMgaW4gdGhlICJzaW0iIGFycmF5IGlzIGF0IHRoZSBwb3NpdGlvbiBv
ZiB0aGUgbGFyZ2VzdCBjb29yZGluYXRlLgoKCWkxID0gc2ltW2NdWzFdPj0zIGFuZCAxIG9yIDA7
CglqMSA9IHNpbVtjXVsyXT49MyBhbmQgMSBvciAwOwoJazEgPSBzaW1bY11bM10_PTMgYW5kIDEg
b3IgMDsKCWwxID0gc2ltW2NdWzRdPj0zIGFuZCAxIG9yIDA7CgktLSBUaGUgbnVtYmVyIDIgaW4g
dGhlICJzaW0iIGFycmF5IGlzIGF0IHRoZSBzZWNvbmQgbGFyZ2VzdCBjb29yZGluYXRlLgoJaTIg
PSBzaW1bY11bMV0_PTIgYW5kIDEgb3IgMDsKCWoyID0gc2ltW2NdWzJdPj0yIGFuZCAxIG9yIDA7
CglrMiA9IHNpbVtjXVszXT49MiBhbmQgMSBvciAwOwoJbDIgPSBzaW1bY11bNF0_PTIgYW5kIDEg
b3IgMDsKCS0tIFRoZSBudW1iZXIgMSBpbiB0aGUgInNpbSIgYXJyYXkgaXMgYXQgdGhlIHNlY29u
ZCBzbWFsbGVzdCBjb29yZGluYXRlLgoJaTMgPSBzaW1bY11bMV0_PTEgYW5kIDEgb3IgMDsKCWoz
ID0gc2ltW2NdWzJdPj0xIGFuZCAxIG9yIDA7CglrMyA9IHNpbVtjXVszXT49MSBhbmQgMSBvciAw
OwoJbDMgPSBzaW1bY11bNF0_PTEgYW5kIDEgb3IgMDsKCS0tIFRoZSBmaWZ0aCBjb3JuZXIgaGFz
IGFsbCBjb29yZGluYXRlIG9mZnNldHMgPSAxLCBzbyBubyBuZWVkIHRvIGxvb2sgdGhhdCB1cC4K
CWxvY2FsIHgxID0geDAgLSBpMSArIEc0OyAtLSBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyIGlu
ICh4LHkseix3KSBjb29yZHMKCWxvY2FsIHkxID0geTAgLSBqMSArIEc0OwoJbG9jYWwgejEgPSB6
MCAtIGsxICsgRzQ7Cglsb2NhbCB3MSA9IHcwIC0gbDEgKyBHNDsKCWxvY2FsIHgyID0geDAgLSBp
MiArIDIuMCpHNDsgLS0gT2Zmc2V0cyBmb3IgdGhpcmQgY29ybmVyIGluICh4LHkseix3KSBjb29y
ZHMKCWxvY2FsIHkyID0geTAgLSBqMiArIDIuMCpHNDsKCWxvY2FsIHoyID0gejAgLSBrMiArIDIu
MCpHNDsKCWxvY2FsIHcyID0gdzAgLSBsMiArIDIuMCpHNDsKCWxvY2FsIHgzID0geDAgLSBpMyAr
IDMuMCpHNDsgLS0gT2Zmc2V0cyBmb3IgZm91cnRoIGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRz
Cglsb2NhbCB5MyA9IHkwIC0gajMgKyAzLjAqRzQ7Cglsb2NhbCB6MyA9IHowIC0gazMgKyAzLjAq
RzQ7Cglsb2NhbCB3MyA9IHcwIC0gbDMgKyAzLjAqRzQ7Cglsb2NhbCB4NCA9IHgwIC0gMS4wICsg
NC4wKkc0OyAtLSBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5LHosdykgY29vcmRzCgls
b2NhbCB5NCA9IHkwIC0gMS4wICsgNC4wKkc0OwoJbG9jYWwgejQgPSB6MCAtIDEuMCArIDQuMCpH
NDsKCWxvY2FsIHc0ID0gdzAgLSAxLjAgKyA0LjAqRzQ7CgoJLS0gV29yayBvdXQgdGhlIGhhc2hl
ZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSBmaXZlIHNpbXBsZXggY29ybmVycwoJbG9jYWwgaWkg
PSBpJjI1NQoJbG9jYWwgamogPSBqJjI1NQoJbG9jYWwga2sgPSBrJjI1NQoJbG9jYWwgbGwgPSBs
JjI1NQoJbG9jYWwgZ2kwID0gcGVybVtpaStwZXJtW2pqK3Blcm1ba2srcGVybVtsbF1dXV0gJSAz
MjsKCWxvY2FsIGdpMSA9IHBlcm1baWkraTErcGVybVtqaitqMStwZXJtW2trK2sxK3Blcm1bbGwr
bDFdXV1dICUgMzI7Cglsb2NhbCBnaTIgPSBwZXJtW2lpK2kyK3Blcm1bamorajIrcGVybVtraytr
MitwZXJtW2xsK2wyXV1dXSAlIDMyOwoJbG9jYWwgZ2kzID0gcGVybVtpaStpMytwZXJtW2pqK2oz
K3Blcm1ba2srazMrcGVybVtsbCtsM11dXV0gJSAzMjsKCWxvY2FsIGdpNCA9IHBlcm1baWkrMStw
ZXJtW2pqKzErcGVybVtraysxK3Blcm1bbGwrMV1dXV0gJSAzMjsKCgktLSBDYWxjdWxhdGUgdGhl
IGNvbnRyaWJ1dGlvbiBmcm9tIHRoZSBmaXZlIGNvcm5lcnMKCWxvY2FsIHQwID0gMC41IC0geDAq
eDAgLSB5MCp5MCAtIHowKnowIC0gdzAqdzA7CglpZiAodDA8MCkgdGhlbgoJCW4wID0gMC4wOwoJ
ZWxzZQoJCXQwID0gdDAqdDA7CgkJbjAgPSB0MCAqIHQwICogRG90NEQoR3JhZGllbnRzNERbZ2kw
XSwgeDAsIHkwLCB6MCwgdzApOwoJZW5kCgoJbG9jYWwgdDEgPSAwLjUgLSB4MSp4MSAtIHkxKnkx
IC0gejEqejEgLSB3MSp3MTsKCWlmICh0MTwwKSB0aGVuCgkJbjEgPSAwLjA7CgllbHNlIAoJCXQx
ID0gdDEqdDE7CgkJbjEgPSB0MSAqIHQxICogRG90NEQoR3JhZGllbnRzNERbZ2kxXSwgeDEsIHkx
LCB6MSwgdzEpOwoJZW5kCgoJbG9jYWwgdDIgPSAwLjUgLSB4Mip4MiAtIHkyKnkyIC0gejIqejIg
LSB3Mip3MjsKCWlmICh0MjwwKSB0aGVuCgkJbjIgPSAwLjA7CgllbHNlCgkJdDIgPSB0Mip0MjsK
CQluMiA9IHQyICogdDIgKiBEb3Q0RChHcmFkaWVudHM0RFtnaTJdLCB4MiwgeTIsIHoyLCB3Mik7
CgllbmQKCglsb2NhbCB0MyA9IDAuNSAtIHgzKngzIC0geTMqeTMgLSB6Myp6MyAtIHczKnczOwoJ
aWYgKHQzPDApIHRoZW4KCQluMyA9IDAuMDsKCWVsc2UgCgkJdDMgPSB0Myp0MzsKCQluMyA9IHQz
ICogdDMgKiBEb3Q0RChHcmFkaWVudHM0RFtnaTNdLCB4MywgeTMsIHozLCB3Myk7CgllbmQKCgls
b2NhbCB0NCA9IDAuNSAtIHg0Kng0IC0geTQqeTQgLSB6NCp6NCAtIHc0Knc0OwoJaWYgKHQ0PDAp
IHRoZW4KCQluNCA9IDAuMDsKCWVsc2UKCQl0NCA9IHQ0KnQ0OwoJCW40ID0gdDQgKiB0NCAqIERv
dDREKEdyYWRpZW50czREW2dpNF0sIHg0LCB5NCwgejQsIHc0KTsKCWVuZAoKCS0tIFN1bSB1cCBh
bmQgc2NhbGUgdGhlIHJlc3VsdCB0byBjb3ZlciB0aGUgcmFuZ2UgWy0xLDFdCgoJbG9jYWwgcmV0
dmFsID0gMjcuMCAqIChuMCArIG4xICsgbjIgKyBuMyArIG40KQoKCWlmIHNpbXBsZXguaW50ZXJu
YWxDYWNoZSB0aGVuCgkJaWYgbm90IFByZXY0RFt4XSB0aGVuIFByZXY0RFt4XSA9IHt9IGVuZAoJ
CWlmIG5vdCBQcmV2NERbeF1beV0gdGhlbiBQcmV2NERbeF1beV0gPSB7fSBlbmQKCQlpZiBub3Qg
UHJldjREW3hdW3ldW3pdIHRoZW4gUHJldjREW3hdW3ldW3pdID0ge30gZW5kCgkJUHJldjREW3hd
W3ldW3pdW3ddID0gcmV0dmFsCgllbmQKCglyZXR1cm4gcmV0dmFsOwoKZW5kIAoKbG9jYWwgZSA9
IDIuNzE4MjgxODI4NDU5MDQ1MjM1MzYKCmxvY2FsIFByZXZCbHVyMkQgPSB7fQoKZnVuY3Rpb24g
c2ltcGxleC5HQmx1cjJEKHgseSxzdGREZXYpCglpZiBzaW1wbGV4LmludGVybmFsQ2FjaGUgYW5k
IFByZXZCbHVyMkRbeF0gYW5kIFByZXZCbHVyMkRbeF1beV0gYW5kIFByZXZCbHVyMkRbeF1beV1b
c3RkRGV2XSB0aGVuIHJldHVybiBQcmV2Qmx1cjJEW3hdW3ldW3N0ZERldl0gZW5kCglsb2NhbCBw
d3IgPSAoKHheMit5XjIpLygyKihzdGREZXZeMikpKSotMQoJbG9jYWwgcmV0ID0gKDEvKDIqbWF0
aC5waSooc3RkRGV2XjIpKSkqKGVecHdyKQoKCWlmIHNpbXBsZXguaW50ZXJuYWxDYWNoZSB0aGVu
CgkJaWYgbm90IFByZXZCbHVyMkRbeF0gdGhlbiBQcmV2Qmx1cjJEW3hdID0ge30gZW5kCgkJaWYg
bm90IFByZXZCbHVyMkRbeF1beV0gdGhlbiBQcmV2Qmx1cjJEW3hdW3ldID0ge30gZW5kCgkJUHJl
dkJsdXIyRFt4XVt5XVtzdGREZXZdID0gcmV0CgllbmQKCXJldHVybiByZXQKZW5kIAoKbG9jYWwg
UHJldkJsdXIxRCA9IHt9CgpmdW5jdGlvbiBzaW1wbGV4LkdCbHVyMUQoeCxzdGREZXYpCglpZiBz
aW1wbGV4LmludGVybmFsQ2FjaGUgYW5kIFByZXZCbHVyMURbeF0gYW5kIFByZXZCbHVyMURbeF1b
c3RkRGV2XSB0aGVuIHJldHVybiBQcmV2Qmx1cjFEW3hdW3N0ZERldl0gZW5kCglsb2NhbCBwd3Ig
PSAoeF4yLygyKnN0ZERldl4yKSkqLTEKCWxvY2FsIHJldCA9ICgxLyhtYXRoLnNxcnQoMiptYXRo
LnBpKSpzdGREZXYpKSooZV5wd3IpCgoJaWYgc2ltcGxleC5pbnRlcm5hbENhY2hlIHRoZW4KCQlp
ZiBub3QgUHJldkJsdXIxRFt4XSB0aGVuIFByZXZCbHVyMURbeF0gPSB7fSBlbmQKCQlQcmV2Qmx1
cjFEW3hdW3N0ZERldl0gPSByZXQKCWVuZAoJcmV0dXJuIHJldAplbmQKCmZ1bmN0aW9uIHNpbXBs
ZXguRnJhY3RhbFN1bShmdW5jLCBpdGVyLCAuLi4pCiAgICBsb2NhbCByZXQgPSBmdW5jKC4uLikK
ICAgIGZvciBpPTEsaXRlciBkbwogICAgICAgIGxvY2FsIHBvd2VyID0gMl5pdGVyCiAgICAgICAg
bG9jYWwgcyA9IHBvd2VyL2kKCiAgICAgICAgbG9jYWwgc2NhbGVkID0ge30KICAgICAgICBmb3Ig
ZWxlbSBpbiBpcGFpcnMoey4uLn0pIGRvCiAgICAgICAgICAgIHRhYmxlLmluc2VydChzY2FsZWQs
IGVsZW0qcykKICAgICAgICBlbmQKICAgICAgICByZXQgPSByZXQgKyAoaS9wb3dlcikqKGZ1bmMo
dW5wYWNrKHNjYWxlZCkpKQogICAgZW5kCiAgICByZXR1cm4gcmV0CmVuZAoKZnVuY3Rpb24gc2lt
cGxleC5GcmFjdGFsU3VtQWJzKGZ1bmMsIGl0ZXIsIC4uLikKICAgIGxvY2FsIHJldCA9IG1hdGgu
YWJzKGZ1bmMoLi4uKSkKICAgIGZvciBpPTEsaXRlciBkbwogICAgICAgIGxvY2FsIHBvd2VyID0g
Ml5pdGVyCiAgICAgICAgbG9jYWwgcyA9IHBvd2VyL2kKCiAgICAgICAgbG9jYWwgc2NhbGVkID0g
e30KICAgICAgICBmb3IgZWxlbSBpbiBpcGFpcnMoey4uLn0pIGRvCiAgICAgICAgICAgIHRhYmxl
Lmluc2VydChzY2FsZWQsIGVsZW0qcykKICAgICAgICBlbmQKICAgICAgICByZXQgPSByZXQgKyAo
aS9wb3dlcikqKG1hdGguYWJzKGZ1bmModW5wYWNrKHNjYWxlZCkpKSkKICAgIGVuZAogICAgcmV0
dXJuIHJldAplbmQKCmZ1bmN0aW9uIHNpbXBsZXguVHVyYnVsZW5jZShmdW5jLCBkaXJlY3Rpb24s
IGl0ZXIsIC4uLikKICAgIGxvY2FsIHJldCA9IG1hdGguYWJzKGZ1bmMoLi4uKSkKICAgIGZvciBp
PTEsaXRlciBkbwogICAgICAgIGxvY2FsIHBvd2VyID0gMl5pdGVyCiAgICAgICAgbG9jYWwgcyA9
IHBvd2VyL2kKCiAgICAgICAgbG9jYWwgc2NhbGVkID0ge30KICAgICAgICBmb3IgZWxlbSBpbiBp
cGFpcnMoey4uLn0pIGRvCiAgICAgICAgICAgIHRhYmxlLmluc2VydChzY2FsZWQsIGVsZW0qcykK
ICAgICAgICBlbmQKICAgICAgICByZXQgPSByZXQgKyAoaS9wb3dlcikqKG1hdGguYWJzKGZ1bmMo
dW5wYWNrKHNjYWxlZCkpKSkKICAgIGVuZAogICAgbG9jYWwgYXJncyA9IHsuLi59CiAgICBsb2Nh
bCBkaXJfY29tcG9uZW50ID0gYXJnc1tkaXJlY3Rpb24rMV0KICAgIHJldHVybiBtYXRoLnNpbihk
aXJfY29tcG9uZW50K3JldCkKZW5k
:: util.lua
--[[pod_format="raw",created="2025-04-12 19:25:23",modified="2025-05-22 17:45:13",revision=2232]]

local perf_rec = {}
local perf_c = 1
local lag_counter = 0
function perf_graph()
	perf_c = (perf_c + 1)%60
	perf_rec[perf_c] = stat(1) * 10
	local acc = 0
	local m = 0
	for i,v in pairs(perf_rec) do
		pset(i,SCREEN_HEIGHT - 10, 8)
		pset(i,SCREEN_HEIGHT - 8, 1)
		pset(i,SCREEN_HEIGHT - v,7)
		acc += v
		if v > m then m = v end
	end
	if stat(7) < 60 then lag_counter += 1 end
	m = flr(m*10)
	local avg = flr(acc / 6)
	prints("lag " .. lag_counter,62, SCREEN_HEIGHT - 32)
	prints("avg " .. avg .. "%",62,SCREEN_HEIGHT - 24)
	prints("max " .. m .. "%",62,SCREEN_HEIGHT - 16)
	prints("cur " .. flr(stat(1)*100) .. "% // target " .. stat(7),62,SCREEN_HEIGHT - 8)
end

local bars = {}

function draw_debug_bars()
	local last_bar_top = 0
	for n,bar in pairs(bars) do
		local next_bar_top = last_bar_top + (bar.max_slice_frame * 100)
		rectfill(SCREEN_WIDTH,last_bar_top, SCREEN_WIDTH - 8, next_bar_top, bar.color)
		rect(SCREEN_WIDTH,last_bar_top, SCREEN_WIDTH - 8, next_bar_top, 1)
		print(n,SCREEN_WIDTH-#n*5-8,last_bar_top)
		local perf_text = "WCpF " .. flr(bar.max_slice_frame * 100) .. "%"
		print(perf_text,SCREEN_WIDTH-#perf_text*5-8,last_bar_top+8)
		last_bar_top = next_bar_top
	end
end

function start_bar_frame()
	for n,bar in pairs(bars) do
		bar.frame_slice = 0
		if key("tab") then
			bar.max_slice = 0
			bar.max_slice_frame = 0
		end
	end
end

function bar_start(n)
	local bar = bars[n]
	if not bar then 
		bar = {
			max_slice = 0,
			frame_slice = 0,
			max_slice_frame = 0,
			color = flr(rnd(29)+2)
		}
		bars[n] = bar
	end
	bar.waiting_slice = stat(1)
end

function bar_end(n)
	local bar = bars[n]
	bar.current_slice = stat(1) - bar.waiting_slice
	bar.frame_slice += bar.current_slice
	
	if bar.max_slice_frame < bar.frame_slice then bar.max_slice_frame = bar.frame_slice end
	if bar.max_slice < bar.current_slice then bar.max_slice = bar.current_slice end
end



function prints(s,x,y,c)
	print(s,x+1,y+1,19)
	print(s,x,y,c or 7)
end

function real_count(t)
	local c = 0
	for i,v in pairs(t) do c+=1 end
	return c
end

function indexof(t,iv)
	for i,ov in pairs(t) do if iv == ov then return i end end
end

function tracked_rect(w,h,cb)
	bar_start("Rect")
	local short_side = w < h and w or h
	local half_short_side = short_side/2
	for ix=0,w do
		for iy=0,h do
			local dist = abs(half_short_side - ix) + abs(half_short_side - iy)
			local inverse_dist = half_short_side - dist
			inverse_dist = inverse_dist < 0 and 0 or inverse_dist
			cb(ix,iy,dist,inverse_dist)
		end
	end
	bar_end("Rect")
end


:: world_interaction.lua
--[[pod_format="raw",created="2025-04-16 12:52:53",modified="2025-05-22 17:45:13",revision=1160]]
include "constants.lua"
include "chunk.lua"

WORLD_MOUSE_X = 0
WORLD_MOUSE_Y = 0
PREV_MOUSE_LEFT = false
PREV_MOUSE_RIGHT = false
function update_world_mouse(camera_x, camera_y)
	local g_mouse_x, g_mouse_y, g_mouse_b, g_wheel_x, g_wheel_y = mouse()
	local left_down = g_mouse_b & 0x1 > 0
	local right_down = g_mouse_b & 0x2 > 0
	local wheel_delta = sgn(g_wheel_y)
	
	local left_pressed = left_down and not PREV_MOUSE_LEFT
	local left_released = not left_down and PREV_MOUSE_LEFT
	
	local right_pressed = right_down and not PREV_MOUSE_RIGHT
	local right_released = not right_down and PREV_MOUSE_RIGHT
	
	PREV_MOUSE_LEFT = left_down
	PREV_MOUSE_RIGHT = right_down
	WORLD_MOUSE_X = flr((camera_x + g_mouse_x) / TILE_SIZE)
	WORLD_MOUSE_Y = flr((camera_y + g_mouse_y) / TILE_SIZE)
	
	if (left_pressed) then
		chunk.set_tile_in_world(WORLD_MOUSE_X, WORLD_MOUSE_Y, 16)
		chunk.place_light_in_world(WORLD_MOUSE_X, WORLD_MOUSE_Y, 32)
	end
	
	if (right_down) then
		chunk.set_tile_in_world(WORLD_MOUSE_X, WORLD_MOUSE_Y, 0)
		chunk.break_light_in_world(WORLD_MOUSE_X, WORLD_MOUSE_Y)
	end
end

function draw_world_mouse()
	local rx = WORLD_MOUSE_X * TILE_SIZE
	local ry = WORLD_MOUSE_Y * TILE_SIZE
	fillp(0b1010010110100101)
	rect(rx+1, ry+1, rx+TILE_SIZE, ry+TILE_SIZE, 1)
	rect(rx, ry, rx+TILE_SIZE-1, ry+TILE_SIZE-1, 7)
	fillp()
end
:: .info.pod
b64$LS1bW3BvZCxiYnNfaWQ9Il9kZXYyMjc5IixjcmVhdGVkPSIyMDI1LTA0LTA5IDE5OjUwOjMx
IixpY29uPXVzZXJkYXRhKCJ1OCIsMTYsMTYsIjAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAw
MDAwMDAwMDAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAwMDAwMDAxMDcxNTE1MTUwYTBhMGEwYTE1
MTUxNTA3MDEwMDAxMDcxNTE1MTUwYTBhMDkwNjA3MGExNTE1MTUwNzAxMDEwNzE1MTUxNTA5MDkw
OTA3MDcwOTE1MTUxNTA3MDEwMTA3MTUxNTE5MTkxOTE5MTkxOTE5MTkxNTE1MDcwMTAxMDcxNTE1
MTUwNzA3MDEwNzA3MDExNTE1MTUwNzAxMDEwNzE1MTUxNTA3MDcwMTA3MDcwMTE1MTUxNTA3MDEw
MTA3MTUxNTE1MTAwNzA3MDcwNzA3MTUxNTE1MDcwMTAxMDcxNTE1MTUwNzEwMDcwNzA3MDcxNTE1
MTUwNzAxMDEwNzAxMTUxNTEwMTAxMDEwMTAxMDE1MTUxNTA3MDEwMTA2MDcxNTE1MTAxMDAxMDEx
MDEwMTUxNTA3MDYwMTAxMDYwNjA3MDcwNzA3MDcwNzA3MDcwNzA3MDYwNjAxMDAwMTA2MDYwNjA2
MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAwMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAwMDAw
MDAxMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwIiksbG93Y29sX2ljb249ZmFsc2UsbW9kaWZpZWQ9
IjIwMjUtMDUtMjIgMTc6NDU6MTQiLHJ1bnRpbWU9MTgsc2FuZGJveD1mYWxzZSx3b3Jrc3BhY2Vz
PXt7bG9jYXRpb249Im1haW4ubHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImNo
dW5rLmx1YSM0MDgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImVudGl0aWVzL3BsYXll
ci5sdWEjMSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0id29ybGRfaW50ZXJhY3Rpb24u
bHVhIzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InV0aWwubHVhIzk3Iix3b3Jrc3Bh
Y2VfaW5kZXg9MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9j
YXRpb249ImdmeC8xLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwL2RlYnVn
Lm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3BhY2Vf
aW5kZXg9NH19XV0=
:: [eoc]
